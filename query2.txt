Product.js:
const mongoose = require("mongoose")

// Schema for dynamic key-value pairs (Product Details, Optional Details)
const keyValueSchema = mongoose.Schema({
  key: { type: String, required: false }, // Made optional for testing
  value: { type: String, required: false }, // Made optional for testing
})

// Schema for Bulk Pricing
const bulkPricingSchema = mongoose.Schema({
  wholesalePrice: { type: Number, required: false }, // Made optional for testing
  quantity: { type: Number, required: false }, // Made optional for testing
})

// Schema for a single Size object
const singleSizeSchema = mongoose.Schema({
  length: { type: Number, required: false },
  breadth: { type: Number, required: false },
  height: { type: Number, required: false },
  unit: { type: String, enum: ["cm", "m", "inch"], required: false }, // Changed to required: false
})

// Schema for 'More Details' section (now representing a specific Size instance)
const moreDetailsSchema = mongoose.Schema({
  size: singleSizeSchema, // This should be an object, not an array
  additionalImages: [String], // Array of Cloudinary URLs
  optionalDetails: [keyValueSchema],
  // Fields for price/stock if they are specific to this moreDetails section
  price: { type: Number, required: false },
  stock: { type: Number, required: false },
  lastRestockedAt: {type: Date, required: false, default: null},
  discountStartDate: {type: Date, required: false, default: null},
    discountEndDate: {type: Date, required: false, default: null},
    discountPrice: {type: Number, required: false, default: ""},
    comeBackToOriginalPrice: {type: Boolean, required: false, default: null},
    discountBulkPricing: [{
  wholesalePrice: { type: Number },
  quantity: { type: Number }
}],
  bulkPricingCombinations: [bulkPricingSchema],
})

// Schema for Product Variants
const productVariantSchema = mongoose.Schema({
  colorName: { type: String, required: false }, // Made optional for testing
  variantImage: { type: String, required: false }, // Cloudinary URL
  optionalDetails: [keyValueSchema], // Variant-specific optional details
  moreDetails: [moreDetailsSchema], // Array of 'More Details' sections (each representing a unique size instance)
  // Fields for price/stock if they are common for all moreDetails sections of this variant
  commonPrice: { type: Number, required: false },
  commonStock: { type: Number, required: false },
  commonBulkPricingCombinations: [bulkPricingSchema],
  isDefault: { type: Boolean, default: false }, // New field for default variant
})

// Main Product Schema
const productSchema = mongoose.Schema(
  {
    name: { type: String, required: false, trim: true }, // Made optional for testing
    mainCategory: { type: mongoose.Schema.Types.ObjectId, ref: "Category", required: false }, // Made optional for testing
    subCategory: { type: mongoose.Schema.Types.ObjectId, ref: "Category", required: false }, // Made optional for testing
    categoryPath: { type: String, required: false }, // e.g., Electronics > Mobiles > Vivo // Made optional for testing
    productDetails: [keyValueSchema],
    stock: { type: Number, required: false, default: "" }, // Required if no variants
    price: { type: Number, required: false, default: "" }, // Required if no variants
    lastRestockedAt: {type: Date, required: false, default: null},
    discountStartDate: {type: Date, required: false, default: null},
    discountEndDate: {type: Date, required: false, default: null},
    discountPrice: {type: Number, required: false, default: ""},
    comeBackToOriginalPrice: {type: Boolean, required: false, default: null},
    discountBulkPricing: [{
  wholesalePrice: { type: Number },
  quantity: { type: Number }
}],
    image: { type: String, required: false, default: "" }, // Main product image URL (Cloudinary)
    additionalImages: [String], // Array of Cloudinary URLs for basic product
    bulkPricing: [bulkPricingSchema], // Bulk pricing for basic product

    hasVariants: { type: Boolean, default: false }, // Flag to indicate if product has variants
    variants: [productVariantSchema], // Array of product variants
  },
  {
    timestamps: true,
  },
)

module.exports = mongoose.model("Product", productSchema)

Category.js:
const mongoose = require('mongoose');

const categorySchema = mongoose.Schema({
  categoryName: {
    type: String,
    required: true,
    trim: true,
  },
  parent_category_id: {
    type: mongoose.Schema.Types.ObjectId,
    default: null,
    required: false,
    ref: 'Category',
  },
  image: {
    type: String, // Store Cloudinary image URL for main categories
    required: false,
  },
}, {
  timestamps: true,
});

// Index for faster queries on parent_category_id
categorySchema.index({ parent_category_id: 1 });

module.exports = mongoose.model('Category', categorySchema);

SubCategory.js:
No sperate file all in Catgeory.js

cartRoutes.js:
const express = require("express")
const Cart = require("../models/Cart") // Adjust path as needed
const router = express.Router()

// Middleware to check authentication
const requireAuth = (req, res, next) => {
  if (!req.user || !req.user.id) {
    return res.status(401).json({ error: "Authentication required" })
  }
  next()
}

// Apply authentication middleware to all routes
router.use(requireAuth)

// GET /api/cart - Fetch all cart items for user
router.get("/", async (req, res) => {
  try {
    const cartItems = await Cart.find({ user_id: req.user.id })
    res.status(200).json(cartItems)
  } catch (error) {
    console.error("Error fetching cart:", error)
    res.status(500).json({ error: "Failed to fetch cart items" })
  }
})

// POST /api/cart - Add item to cart
router.post("/", async (req, res) => {
  try {
    const {
      image_url,
      product_id,
      variant_id,
      details_id,
      size_id,
      product_name,
      variant_name,
      size,
      quantity,
      price,
      cash_applied,
      discounted_price,
    } = req.body

    const existingItem = await Cart.findOne({
      user_id: req.user.id,
      product_id,
      variant_name: variant_name || null,
      size: size || null,
    })

    if (existingItem) {
      // Update quantity if item exists
      existingItem.quantity += quantity
      await existingItem.save()
      res.status(200).json(existingItem)
    } else {
      const cartItemData = {
        user_id: req.user.id,
        image_url,
        product_id,
        product_name,
        quantity,
        price,
        cash_applied,
        discounted_price,
      }

      // Only add variant fields if they exist
      if (variant_id) cartItemData.variant_id = variant_id
      if (details_id) cartItemData.details_id = details_id
      if (size_id) cartItemData.size_id = size_id
      if (variant_name) cartItemData.variant_name = variant_name
      if (size) cartItemData.size = size

      const newCartItem = new Cart(cartItemData)
      await newCartItem.save()
      res.status(201).json(newCartItem)
    }
  } catch (error) {
    console.error("Error adding to cart:", error)
    res.status(500).json({ error: "Failed to add item to cart" })
  }
})

// PUT /api/cart - Update item quantity
router.put("/", async (req, res) => {
  try {
    const { product_id, variant_name, size, quantity } = req.body

    const cartItem = await Cart.findOneAndUpdate(
      {
        user_id: req.user.id,
        product_id,
        variant_name,
        size,
      },
      { quantity },
      { new: true },
    )

    if (!cartItem) {
      return res.status(404).json({ error: "Cart item not found" })
    }

    res.status(200).json(cartItem)
  } catch (error) {
    console.error("Error updating cart:", error)
    res.status(500).json({ error: "Failed to update cart item" })
  }
})

// DELETE /api/cart - Remove item from cart
router.delete("/", async (req, res) => {
  try {
    const { product_id, variant_name, size } = req.body

    const deletedItem = await Cart.findOneAndDelete({
      user_id: req.user.id,
      product_id,
      variant_name,
      size,
    })

    if (!deletedItem) {
      return res.status(404).json({ error: "Cart item not found" })
    }

    res.status(200).json({ message: "Item removed from cart" })
  } catch (error) {
    console.error("Error removing from cart:", error)
    res.status(500).json({ error: "Failed to remove item from cart" })
  }
})

// DELETE /api/cart/clear - Clear entire cart
router.delete("/clear", async (req, res) => {
  try {
    await Cart.deleteMany({ user_id: req.user.id })
    res.status(200).json({ message: "Cart cleared successfully" })
  } catch (error) {
    console.error("Error clearing cart:", error)
    res.status(500).json({ error: "Failed to clear cart" })
  }
})

module.exports = router

cartController.js:-
Functions have been implemented in cartRoutes.js only

userController.js:
const User = require('../models/User');
const Order = require('../models/Order');
const mongoose = require('mongoose');

const findUser = async (req, res) => {
    try {
        // console.log(req.body);
        const {userId} = req.body;
        console.log(userId);
        if(!userId || !mongoose.Types.ObjectId.isValid(userId)) {
            // UserId is not valid
            return res.status(400).json({message: "Invalid User ID from reqbody"})
        } else {
            // User ID is valid

            // Checking whether the user exists
            try {
                const user = await User.findById(userId);
                if(user) {
                    // Fetch the orders
                    const userAddress = {
                        state: user.state,
                        city: user.city,
                        zipCode: user.zip_code,
                        address: user.address,
                    }
                    try {
                        const orders = await Order.find({user_id: userId});
                        // console.log(orders)
                        if(orders && orders.length != 0) {
                            // console.log(orders)
                            return res.status(200).json(
                                {
                                    message: "Orders Fetched",
                                    orders: orders,
                                    userAddress
                                }
                            )
                        } else {
                            // User has not ordered anything
                            return res.status(200).json({message: "No orders placed"});
                        }
                    } catch (error) {
                        return res.status(400).json({message: "Problem while fetching orders"});
                    }
                    
                } else {
                    // User not found
                    return res.status(400).json({message: "Invalid User ID from else"});
                }
            } catch (error) {
                return res.status(400).json({message: "Invalid User ID from catch"});
            }
        }
    } catch(error) {
        return res.status(500).json({message: "Server problem"});
    }
}

const fetchUsers = async (req, res) => {
    console.log("Request received fro fetching the users");
    try {
        const users = await User.find({});

        if(!users || users.length == 0) {
            console.log("Inside first if block");
            return res.status(200).json({
                message: "No users found",
            });
        }
        console.log(users);
        return res.status(200).json(
            {
                message: "Users fetched successfully",
                users
            }
        )
    } catch(error) {
        console.log("Inside catch block");
        console.log(error.message);
        return res.status(400).json(
            {
                message: "Error fetching users",
                error: error.message,
            }
        );
    }   
};

// This function will be used buy other controllers to check whether the us4er esxists or not
const findUserById = async (userId) => {
  try {
    const user = await User.findById(userId);
    return user; // will be null if not found
  } catch (err) {
    throw new Error("Error while finding user: " + err.message);
  }
};

module.exports = {
    findUser,
    fetchUsers,
    findUserById
}

categoryController.js:
const Category = require('../models/Category');

// Fetching all the categories (This function is not intended for fteching the categories while the adding the product)
const fetchCategories = async (req, res) => {
    try {
        const categories = await Category.find({});

        if(!categories || categories.length == 0) {
            return res.status(200).json({message: "No categories found"});
        }

        // categories found
        return res.status(200).json({message: "categories found", categories});
    } catch(error) {
        return res.status(400).json({message: "Error while fetching categories", error})
    }
};

// This function will be used by other controller for checking whether categopry exists or not
const findCategoryById = async (categoryID) => {
    try {
        const category = await Category.findById(categoryID);
        return category;
    } catch (error) {
        throw new Error("Error while finding category " + error.message);
    }
}

const findSubCategoryById = async (categoryID) => {
    try {
        const category = await Category.findById(categoryID);
        return category;
    } catch (error) {
        throw new Error("Error while finding category " + error.message);
    }
}

module.exports = {
    fetchCategories,
    findCategoryById,
    findSubCategoryById
}

addCategoryController.js:
const Category = require('../models/Category');
const { cloudinary } = require('../utils/cloudinary');
const multer = require('multer');

// Configure multer for in-memory storage
const storage = multer.memoryStorage();
const upload = multer({ storage });

const addCategory = async (req, res) => {
  console.log('Adding category request received:', JSON.stringify(req.body, null, 2));
  try {
    const { categories } = req.body;
    const imageFile = req.file;

    if (!categories) {
      console.log('Categories data is required');
      return res.status(400).json({ error: 'Categories data is required' });
    }

    // Parse categories if it's a string (from FormData)
    let parsedCategories;
    try {
      parsedCategories = JSON.parse(categories);
    } catch (error) {
      console.log('Invalid categories JSON format');
      return res.status(400).json({ error: 'Invalid categories JSON format' });
    }

    if (!Array.isArray(parsedCategories) || parsedCategories.length === 0) {
      console.log('Categories array is required');
      return res.status(400).json({ error: 'Categories array is required' });
    }

    if (!parsedCategories[0].categoryName) {
      console.log('Main category name is required');
      return res.status(400).json({ error: 'Main category name is required' });
    }

    let imageUrl = null;
    if (imageFile) {
      // Upload image to Cloudinary
      const uploadResult = await new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          { folder: 'categories' },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        );
        uploadStream.end(imageFile.buffer);
      });
      imageUrl = uploadResult.secure_url;
      console.log('Image uploaded to Cloudinary:', imageUrl);
    }

    // Validate that only main category can have an image
    for (const category of parsedCategories) {
      if (category.parent_category_id !== null && category.image) {
        console.log('Only main categories can have images');
        return res.status(400).json({ error: 'Only main categories can have images' });
      }
      if (category.image && !isValidUrl(category.image)) {
        console.log('Invalid image URL provided');
        return res.status(400).json({ error: 'Invalid image URL' });
      }
    }

    // Update main category with Cloudinary image URL
    if (imageUrl) {
      parsedCategories[0].image = imageUrl;
    }

    const savedCategoryIds = {};
    const savedCategories = [];

    for (const category of parsedCategories) {
      let parentId = null;

      if (category.parent_category_id) {
        console.log(`Processing parent_category_id: ${category.parent_category_id}`);

        if (category.parent_category_id === 'main') {
          parentId = savedCategoryIds['main'];
        } else {
          const pathKey = category.parent_category_id;
          if (!savedCategoryIds[pathKey]) {
            console.log(`Invalid parent_category_id: ${category.parent_category_id} (path: ${pathKey})`);
            return res.status(400).json({ error: `Invalid parent_category_id: ${category.parent_category_id}` });
          }
          parentId = savedCategoryIds[pathKey];
        }
      }

      console.log(`Saving category: ${category.categoryName}, parentId: ${parentId || 'null'}`);

      const newCategory = new Category({
        categoryName: category.categoryName,
        parent_category_id: parentId,
        image: category.image || null,
      });

      const saved = await newCategory.save();
      savedCategories.push(saved);

      if (category.parent_category_id === null) {
        savedCategoryIds['main'] = saved._id;
        console.log(`Saved main category: ${category.categoryName}, _id: ${saved._id}`);
      } else {
        const currentPath = category.current_path;
        if (currentPath) {
          savedCategoryIds[currentPath] = saved._id;
          console.log(`Saved subcategory: ${category.categoryName}, path: ${currentPath}, _id: ${saved._id}`);
        }
      }
    }

    res.status(201).json({
      message: 'Categories created successfully',
      categories: savedCategories,
    });
  } catch (error) {
    console.error('Error creating categories:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Helper function to validate URL
const isValidUrl = (string) => {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
};

// Export the controller wrapped with multer middleware
module.exports = {
  addCategory: [upload.single('image'), addCategory],
};

getAllCategoriesController.js:
// controllers/getAllCategoriesController.js
const Category = require('../models/Category');

const buildCategoryTree = (categories, parentId = null) => {
  return categories
    .filter(cat => String(cat.parent_category_id) === String(parentId))
    .map(cat => ({
      _id: cat._id,
      categoryName: cat.categoryName,
      image: cat.image || null,
      subcategories: buildCategoryTree(categories, cat._id)
    }));
};

const getAllCategories = async (req, res) => {
  try {
    const categories = await Category.find().lean();
    const tree = buildCategoryTree(categories);
    res.status(200).json(tree);
  } catch (error) {
    console.error("Error fetching categories:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
};

module.exports = getAllCategories;

categoryController, addCategoryController, getAllCategoriesController these are hee files for categories previously I had separated them

ProductContext.js:
import { createContext, useState, useEffect, useContext } from "react";
import axios from "axios";
import { AuthContext } from "./AuthContext.jsx";

export const ProductContext = createContext();

export const ProductProvider = ({ children }) => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user, loading: authLoading } = useContext(AuthContext);

  useEffect(() => {
    const fetchProducts = async () => {
      if (!authLoading && user) {
        try {
          const response = await axios.get(
            "http://localhost:3000/api/product/all",
            { withCredentials: true } // Include cookies (JWT token)
          );
          setProducts(response.data.products);
          setLoading(false);
        } catch (err) {
          setError(err.response?.data?.message || "Error fetching products");
          setLoading(false);
        }
      } else if (!authLoading && !user) {
        setProducts([]);
        setLoading(false);
      }
    };

    fetchProducts();
  }, [user, authLoading]);

  return (
    <ProductContext.Provider value={{ products, loading, error }}>
      {children}
    </ProductContext.Provider>
  );
};

Cart.js:
const mongoose = require("mongoose")

const cartSchema = mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
    },
    image_url: {
      type: String,
      required: true,
    },
    product_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
    },
    variant_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: false,
      default: null,
    },
    details_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: false,
      default: null,
    },
    size_id: {
      type: mongoose.Schema.Types.ObjectId,
      required: false,
      default: null,
    },
    product_name: {
      type: String,
      required: true,
    },
    variant_name: {
      type: String,
      required: false,
      default: null,
    },
    size: {
      type: String,
      required: false,
      default: null,
    },
    quantity: {
      type: Number,
      required: true,
      min: 1,
    },
    price: {
      type: Number,
      required: true,
      min: 1,
    },
    cash_applied: {
      type: Boolean,
      required: true,
    },
    discounted_price: {
      type: Number,
      required: true,
    },
  },
  {
    timestamps: true,
  },
)

module.exports = mongoose.model("Cart", cartSchema)


Here are the files you requested. Now also say if you want more files than say me I will provide you the files ask without any hesitation. You need to keep the existing functiona;ity same as the backend has been alreaddy implemented for all oher functionalities now you need to implement free cash functionaly. If you need more files just say the name of the files required. if you have any confusion then ask dont generate code if you have confusion or want more files
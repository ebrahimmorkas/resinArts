AuthContext.jsx:
import { useContext, useState, useEffect, Children, createContext } from 'react';
import axios from 'axios';

export const AuthContext = createContext();

export const AuthProvider = ({children}) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

     useEffect(() => {
    const checkLogin = async() => {
      try {
        const res = await axios.get(
          'http://localhost:3000/api/auth/me',
          {withCredentials: true},
        );
        console.log("You are logged in")
        setUser(res.data.user)
      } catch(err) {
        setUser(null);
        // navigate('/auth/login');
      } finally {
        setLoading(false);
      }

    }
    checkLogin();
  }, [])

  return(
    <AuthContext.Provider value={{ user, setUser, loading }}>
        {children}
    </AuthContext.Provider>
  )
}


Login.jsx:
import React, { useState } from 'react';
import axios from 'axios';
import { Link, useNavigate } from 'react-router-dom';
import useAuth from '../../../hooks/useAuth';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [errorMessages, setErrorMessages] = useState('');
  const [isLoading, setLoading] = useState(false);
  const navigate = useNavigate();
  const {setUser} = useAuth();

  const handleSubmit = async (e) => {
    setLoading(true);
    e.preventDefault();
    const formData = {
        email,
        password
    }

    try{
        const res = await axios.post(
          'http://localhost:3000/api/auth/login', 
          formData,
          {withCredentials: true}
        )
        // Setting the global state of the user
        setUser(res.data.user);


        setLoading(false)
        if(res.data.user.role === 'admin') {
          navigate('/admin/panel');
        } else {
          navigate('/');
        }

    } catch(err) {
      setLoading(false)
      setPassword('');
        // console.log(err);
        if(err.response && err.response.data) {
          setErrorMessages(err.response.data.message);
        }
        else {
          setErrorMessages('Something went wrong. Please try again');
        }
    }
    
    console.log('Login submitted:', { email, password });
  };

  return (
    <div className="w-screen h-screen flex items-center justify-center bg-gradient-to-br from-purple-600 via-pink-500 to-blue-500 bg-cover bg-center bg-no-repeat p-0">
      <div className="bg-white bg-opacity-90 backdrop-blur-md rounded-2xl shadow-2xl p-8 w-full max-w-md">
        {/* <div className="flex justify-center mb-6">
          <img src="/assets/mouldmarket-logo.png" alt="Mouldmarket Logo" className="h-16" />
        </div> */}
        <h2 className="text-3xl font-bold text-center text-gray-800 mb-6">Mouldmarket</h2>
        <p className="text-center text-gray-600 mb-8">Sign in to your creative marketplace</p>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div className='bg-red-200 rounded py-4'>{errorMessages}</div>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="mt-1 w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none transition-colors"
              placeholder="your@email.com"
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              type={showPassword ? 'text' : 'password'}
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="mt-1 w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none transition-colors"
              placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            />
            <div className="mt-2 text-left">
              <input
                type="checkbox"
                id="showPassword"
                checked={showPassword}
                onChange={(e) => setShowPassword(e.target.checked)}
                className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
              />
              <label htmlFor="showPassword" className="ml-2 text-sm text-gray-700">
                Show Password
              </label>
            </div>
          </div>
          <button
            type="submit"
            className="w-full py-2 px-4 bg-gradient-to-r from-purple-600 to-pink-500 text-white font-semibold rounded-lg hover:from-purple-700 hover:to-pink-600 focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition-all"
          >
            Sign In
          </button>
          <div className="text-center">
            <a href="/forgot-password" className="text-purple-600 hover:text-purple-800 text-sm font-medium">
              Forgot Password?
            </a>
          </div>
        </form>
        <p className="mt-6 text-center text-sm text-gray-600">
          Don't have an account?{' '}
          <Link to="/auth/signup" className="text-purple-600 hover:text-purple-800 font-medium">
          {
            isLoading ? 'Signing in' : 'Sign up'
          }
            
          </Link>
        </p>
      </div>
    </div>
  );
};

export default Login;

CartContext.jsx:
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import axios from "axios";
import { FreeCashContext } from "./FreeCashContext";
import { ProductContext } from "./ProductContext";

const CartContext = createContext();

export const useCart = () => {
    const context = useContext(CartContext);
    if (!context) {
        throw new Error("useCart must be used within a CartProvider");
    }
    return context;
};

export const CartProvider = ({ children }) => {
    const [cartItems, setCartItems] = useState({});
    const [isCartOpen, setIsCartOpen] = useState(false);
    const [applyFreeCash, setApplyFreeCash] = useState(false);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    
    // Get contexts
    const { freeCash, checkFreeCashEligibility } = useContext(FreeCashContext);
    const { products } = useContext(ProductContext);

    axios.defaults.withCredentials = true;

    // Initial cart fetch
    useEffect(() => {
        fetchCartFromBackend();
    }, []);

    // When free cash context loads, check for eligibility and refresh cart
    useEffect(() => {
        if (freeCash !== null && Object.keys(cartItems).length > 0) {
            // If free cash is available, enable the checkbox by default
            if (freeCash && !freeCash.is_cash_used && !freeCash.is_cash_expired) {
                setApplyFreeCash(false);
            } else {
                setApplyFreeCash(false);
            }
            updateAllCashApplied();
        }
    }, [freeCash]);

    // Recalculate cash applied when applyFreeCash checkbox changes
    useEffect(() => {
        if (Object.keys(cartItems).length > 0) {
            updateAllCashApplied();
        }
    }, [applyFreeCash]);

    const fetchCartFromBackend = async () => {
        try {
            setLoading(true);
            const response = await axios.get("http://localhost:3000/api/cart", {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
            });

            if (response.status === 200) {
                const cartData = response.data;
                const formattedCart = {};
                cartData.forEach((item) => {
                    const cartKey = `${item.product_id}-${item.variant_name || "default"}-${item.size || "default"}`;
                    formattedCart[cartKey] = {
                        productId: item.product_id,
                        variantName: item.variant_name || null,
                        sizeString: item.size || null,
                        quantity: item.quantity,
                        price: item.price,
                        discountedPrice: item.discounted_price,
                        imageUrl: item.image_url,
                        productName: item.product_name,
                        variantId: item.variant_id,
                        detailsId: item.details_id,
                        sizeId: item.size_id,
                        cashApplied: item.cash_applied || 0,
                        userId: item.user_id,
                    };
                });
                setCartItems(formattedCart);
                
                // After loading cart, check for free cash availability
                if (checkFreeCashEligibility) {
                    await checkFreeCashEligibility();
                }
            }
        } catch (err) {
            setError("Failed to load cart");
            console.error("Error fetching cart:", err);
        } finally {
            setLoading(false);
        }
    };

    const addToCart = async (productId, colorName, sizeString, quantity, productData) => {
        try {
            setLoading(true);
            const cartKey = `${productId}-${colorName || "default"}-${sizeString || "default"}`;

            let cashApplied = 0;
            if (applyFreeCash && freeCash) {
                const product = products.find((p) => p._id === productId);
                if (product) {
                    const mockCartData = {
                        ...productData,
                        quantity: quantity,
                        discountedPrice: productData.discountedPrice || productData.price
                    };
                    
                    if (isFreeCashEligible(product, mockCartData, freeCash)) {
                        const itemTotal = mockCartData.discountedPrice * quantity;
                        cashApplied = Math.min(freeCash.amount, itemTotal);
                    }
                }
            }

            const cartItemData = {
                image_url: productData.imageUrl,
                product_id: productId,
                product_name: productData.productName,
                quantity: quantity,
                price: productData.price,
                cash_applied: cashApplied,
                discounted_price: productData.discountedPrice || productData.price,
            };

            if (productData.variantId && productData.variantId !== "") {
                cartItemData.variant_id = productData.variantId;
            }
            if (productData.detailsId && productData.detailsId !== "") {
                cartItemData.details_id = productData.detailsId;
            }
            if (productData.sizeId && productData.sizeId !== "") {
                cartItemData.size_id = productData.sizeId;
            }
            if (colorName && colorName !== "") {
                cartItemData.variant_name = colorName;
            }
            if (sizeString && sizeString !== "") {
                cartItemData.size = sizeString;
            }

            const response = await axios.post("http://localhost:3000/api/cart", cartItemData, {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
            });

            if (response.status === 200 || response.status === 201) {
                setCartItems((prev) => ({
                    ...prev,
                    [cartKey]: {
                        productId,
                        variantName: colorName || null,
                        sizeString: sizeString || null,
                        quantity: (prev[cartKey]?.quantity || 0) + quantity,
                        price: productData.price,
                        discountedPrice: productData.discountedPrice || productData.price,
                        imageUrl: productData.imageUrl,
                        productName: productData.productName,
                        variantId: productData.variantId,
                        detailsId: productData.detailsId,
                        sizeId: productData.sizeId,
                        cashApplied,
                    },
                }));
            } else {
                throw new Error("Failed to add item to cart");
            }
        } catch (err) {
            setError("Failed to add item to cart");
            console.error("Error adding to cart:", err);
        } finally {
            setLoading(false);
        }
    };

    const updateQuantity = async (cartKey, change) => {
        try {
            const item = cartItems[cartKey];
            if (!item) return;

            const newQuantity = item.quantity + change;

            if (newQuantity <= 0) {
                await removeFromCart(cartKey);
                return;
            }

            let cashApplied = 0;
            if (applyFreeCash && freeCash) {
                const product = products.find((p) => p._id === item.productId);
                if (product) {
                    const mockCartData = {
                        ...item,
                        quantity: newQuantity,
                        discountedPrice: item.discountedPrice || item.price
                    };
                    
                    if (isFreeCashEligible(product, mockCartData, freeCash)) {
                        const itemTotal = mockCartData.discountedPrice * newQuantity;
                        cashApplied = Math.min(freeCash.amount, itemTotal);
                    }
                }
            }

            const response = await axios.put(
                "http://localhost:3000/api/cart",
                {
                    product_id: item.productId,
                    variant_name: item.variantName,
                    size: item.sizeString,
                    quantity: newQuantity,
                    cash_applied: cashApplied,
                },
                {
                    withCredentials: true,
                    headers: {
                        "Content-Type": "application/json",
                    },
                },
            );

            if (response.status === 200) {
                setCartItems((prev) => ({
                    ...prev,
                    [cartKey]: {
                        ...prev[cartKey],
                        quantity: newQuantity,
                        cashApplied,
                    },
                }));
            }
        } catch (err) {
            setError("Failed to update quantity");
            console.error("Error updating quantity:", err);
        }
    };

    const removeFromCart = async (cartKey) => {
        try {
            const item = cartItems[cartKey];
            if (!item) return;

            const response = await axios.delete("http://localhost:3000/api/cart", {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
                data: {
                    product_id: item.productId,
                    variant_name: item.variantName,
                    size: item.sizeString,
                },
            });

            if (response.status === 200) {
                setCartItems((prev) => {
                    const newCart = { ...prev };
                    delete newCart[cartKey];
                    return newCart;
                });
            }
        } catch (err) {
            setError("Failed to remove item");
            console.error("Error removing from cart:", err);
        }
    };

    const isFreeCashEligible = (product, item, freeCash) => {
  if (!freeCash) return false;

  const now = new Date();
  if (
    freeCash.is_cash_used ||
    freeCash.is_cash_expired ||
    now < new Date(freeCash.start_date) ||
    (freeCash.end_date && now > new Date(freeCash.end_date))
  ) {
    return false;
  }

  // Calculate total cart value (excluding free cash applied)
  const cartTotal = Object.values(cartItems).reduce((sum, cartItem) => {
    const price = cartItem.discountedPrice || cartItem.price;
    return sum + price * cartItem.quantity;
  }, 0);

  if (cartTotal < freeCash.valid_above_amount) {
    return false;
  }

  if (freeCash.is_cash_applied_on__all_products) {
    return true;
  }

  // Check category restrictions
  if (freeCash.category) {
    const isMainCategoryMatch = product.mainCategory && 
      (product.mainCategory.toString() === freeCash.category.toString() ||
       product.mainCategory._id?.toString() === freeCash.category.toString());
    
    if (!isMainCategoryMatch) {
      return false;
    }

    if (freeCash.sub_category) {
      const isSubCategoryMatch = product.subCategory &&
        (product.subCategory.toString() === freeCash.sub_category.toString() ||
         product.subCategory._id?.toString() === freeCash.sub_category.toString());
      
      if (!isSubCategoryMatch) {
        return false;
      }
    }
  }

  return true;
};

    // Update cash applied for all items when applyFreeCash changes
    const updateAllCashApplied = async () => {
        if (!products || products.length === 0) {
            console.warn("Products not loaded yet, skipping cash update");
            return;
        }

        const updatedItems = {};
        let hasChanges = false;
        let remainingFreeCash = freeCash ? freeCash.amount : 0;

        // Sort items by total value (descending) to prioritize higher value items
        const sortedCartItems = Object.entries(cartItems).sort(([, itemA], [, itemB]) => {
            const totalA = (itemA.discountedPrice || itemA.price) * itemA.quantity;
            const totalB = (itemB.discountedPrice || itemB.price) * itemB.quantity;
            return totalB - totalA;
        });

        for (const [cartKey, item] of sortedCartItems) {
            let cashApplied = 0;
            
            if (applyFreeCash && freeCash && remainingFreeCash > 0) {
                const product = products.find((p) => p._id === item.productId);
                if (product && isFreeCashEligible(product, item, freeCash)) {
                    const itemTotal = (item.discountedPrice || item.price) * item.quantity;
                    cashApplied = Math.min(remainingFreeCash, itemTotal);
                    remainingFreeCash -= cashApplied;
                }
            }

            if (cashApplied !== item.cashApplied) {
                hasChanges = true;
                updatedItems[cartKey] = { ...item, cashApplied };

                // Update on backend
                try {
                    await axios.put(
                        "http://localhost:3000/api/cart",
                        {
                            product_id: item.productId,
                            variant_name: item.variantName,
                            size: item.sizeString,
                            quantity: item.quantity,
                            cash_applied: cashApplied,
                        },
                        {
                            withCredentials: true,
                            headers: {
                                "Content-Type": "application/json",
                            },
                        }
                    );
                } catch (error) {
                    console.error("Error updating cash applied for item:", error);
                }
            } else {
                updatedItems[cartKey] = item;
            }
        }

        if (hasChanges) {
            setCartItems(updatedItems);
        }
    };

    const getCartTotal = () => {
        let total = Object.values(cartItems).reduce((sum, item) => {
            const price = item.discountedPrice || item.price;
            return sum + price * item.quantity;
        }, 0);

        let totalFreeCashApplied = 0;
        if (applyFreeCash && freeCash) {
            totalFreeCashApplied = Object.values(cartItems).reduce((sum, item) => {
                return sum + (item.cashApplied || 0);
            }, 0);
        }

        return Math.max(0, total - totalFreeCashApplied);
    };

    const getUniqueCartItemsCount = () => {
        return Object.keys(cartItems).length;
    };

    const getTotalItemsCount = () => {
        return Object.values(cartItems).reduce((sum, item) => sum + item.quantity, 0);
    };

    const clearCart = async () => {
        try {
            setLoading(true);
            // Clear cart on backend
            const response = await axios.delete("http://localhost:3000/api/cart/clear", {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
            });

            if (response.status === 200) {
                // Clear cart on frontend
                setCartItems({});
                setApplyFreeCash(false); // Reset free cash checkbox
            }
        } catch (err) {
            setError("Failed to clear cart");
            console.error("Error clearing cart:", err);
        } finally {
            setLoading(false);
        }
    };

    const value = {
        cartItems,
        isCartOpen,
        setIsCartOpen,
        applyFreeCash,
        setApplyFreeCash,
        loading,
        error,
        addToCart,
        updateQuantity,
        removeFromCart,
        getCartTotal,
        getUniqueCartItemsCount,
        getTotalItemsCount,
        fetchCartFromBackend,
        clearCart,
    };

    return <CartContext.Provider value={value}>{children}</CartContext.Provider>
};

ProductContext.jsx:
import { createContext, useState, useEffect, useContext } from "react";
import axios from "axios";
import { AuthContext } from "./AuthContext.jsx";

export const ProductContext = createContext();

export const ProductProvider = ({ children }) => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user, loading: authLoading } = useContext(AuthContext);

  useEffect(() => {
    const fetchProducts = async () => {
      if (!authLoading && user) {
        try {
          const response = await axios.get(
            "http://localhost:3000/api/product/all",
            { withCredentials: true } // Include cookies (JWT token)
          );
          setProducts(response.data.products);
          setLoading(false);
        } catch (err) {
          setError(err.response?.data?.message || "Error fetching products");
          setLoading(false);
        }
      } else if (!authLoading && !user) {
        setProducts([]);
        setLoading(false);
      }
    };

    fetchProducts();
  }, [user, authLoading]);

  return (
    <ProductContext.Provider value={{ products, loading, error }}>
      {children}
    </ProductContext.Provider>
  );
};

CategoryContext.jsx:
import { createContext, useState, useEffect } from "react";
import axios from "axios";

export const CategoryContext = createContext();

export const CategoryProvider = ({ children }) => {
  const [loadingCategories, setLoadingCategories] = useState(true);
  const [categoriesErrors, setCategoriesErrors] = useState("");
  const [categories, setCategories] = useState([]);

  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const res = await axios.get(
          "http://localhost:3000/api/category/fetch-categories",
          { withCredentials: true }
        );
        setCategoriesErrors("");
        setCategories(res.data.categories);
      } catch (error) {
        console.log("Problem while fetching categories " + error.message);
        setCategoriesErrors(error.message);
      } finally {
        setLoadingCategories(false);
      }
    };

    fetchCategories();
  }, []); // ðŸ‘ˆ run only once on mount

  return (
    <CategoryContext.Provider
      value={{ categories, loadingCategories, categoriesErrors }}
    >
      {children}
    </CategoryContext.Provider>
  );
};


FreeCashContext.jsx:
import { createContext, useState, useEffect, useContext } from 'react';
import axios from 'axios';
import { AuthContext } from './AuthContext';

export const FreeCashContext = createContext();

export const FreeCashProvider = ({ children }) => {
  const [loadingFreeCash, setLoadingFreeCash] = useState(false);
  const [freeCashErrors, setFreeCashErrors] = useState(null);
  const [freeCash, setFreeCash] = useState(null); // Stores available free cash
  const { user } = useContext(AuthContext);

  // Fetch free cash eligibility
  const checkFreeCashEligibility = async () => {
    if (!user?.id) {
      setFreeCash(null);
      return;
    }

    setLoadingFreeCash(true);
    try {
      const res = await axios.get('http://localhost:3000/api/free-cash/check-eligibility', {
        withCredentials: true,
        headers: {
          "Content-Type": "application/json",
        },
      });
      
      const freeCashData = res.data.freeCash || null;
      setFreeCash(freeCashData);
      setFreeCashErrors(null);
      
      if (freeCashData) {
        localStorage.setItem(`freeCash_${user.id}`, JSON.stringify(freeCashData));
        console.log('Free cash found:', freeCashData);
      } else {
        localStorage.removeItem(`freeCash_${user.id}`);
        console.log('No valid free cash available');
      }
    } catch (err) {
      console.error('Error fetching free cash:', err);
      setFreeCashErrors(err.response?.data?.message || 'Error fetching free cash');
      setFreeCash(null);
      localStorage.removeItem(`freeCash_${user.id}`);
    } finally {
      setLoadingFreeCash(false);
    }
  };

  // Clear free cash cache
  const clearFreeCashCache = () => {
    if (user?.id) {
      localStorage.removeItem(`freeCash_${user.id}`);
      setFreeCash(null);
    }
  };

  // Load cached free cash on mount
  useEffect(() => {
    if (user?.id) {
      const cachedFreeCash = localStorage.getItem(`freeCash_${user.id}`);
      if (cachedFreeCash) {
        try {
          const parsedFreeCash = JSON.parse(cachedFreeCash);
          // Verify it's still valid
          const now = new Date();
          if (!parsedFreeCash.is_cash_used && 
              !parsedFreeCash.is_cash_expired &&
              new Date(parsedFreeCash.end_date) >= now) {
            setFreeCash(parsedFreeCash);
          } else {
            localStorage.removeItem(`freeCash_${user.id}`);
          }
        } catch (error) {
          localStorage.removeItem(`freeCash_${user.id}`);
        }
      }
      // Always check for fresh data
      checkFreeCashEligibility();
    } else {
      setFreeCash(null);
    }
  }, [user?.id]);

  return (
    <FreeCashContext.Provider
      value={{
        loadingFreeCash,
        setLoadingFreeCash,
        freeCashErrors,
        setFreeCashErrors,
        freeCash,
        checkFreeCashEligibility,
        clearFreeCashCache,
      }}
    >
      {children}
    </FreeCashContext.Provider>
  );
};

DiscountContext.jsx:
import axios from 'axios';
import React, { createContext, useEffect, useState } from 'react';

export const DiscountContext = createContext();

export const DiscountProvider = ({children}) => {
    const [discountData, setDiscountData] = useState([]);
    const [loadingDiscount, setLoadingDiscount] = useState(true);
    const [loadingErrors, setLoadingErrors] = useState([]);
    const [isDiscountAvailable, setIsDiscountAvailable] = useState(false);

    useEffect(() => {
        const checkForDiscounts = async () => {
            try {
                const res = await axios.get('http://localhost:3000/api/discount/fetch-discount', {withCredentials: true});
            if(res.status === 200) {
                console.log("Discount data");
                console.log(res.data.data);
                setDiscountData(res.data.data);
                if(res.data.data.length == 0) {
                    setIsDiscountAvailable(false);
                } else {
                    setIsDiscountAvailable(true);
                }
            }
            } catch(error) {
                console.log(error);
                setLoadingErrors(prev => 
  prev.includes(error.message) ? prev : [...prev, error.message]
);

            } finally {
                setLoadingDiscount(false);
            }
        };
        checkForDiscounts()
    }, [])
    return(
        <DiscountContext.Provider value={{ discountData, loadingDiscount, loadingErrors, isDiscountAvailable }}>
            {children}
        </DiscountContext.Provider>
    );
}

BannerContext.jsx:
import React, { createContext, useState, useEffect } from 'react';
import axios from 'axios';

export const BannerContext = createContext();

export const BannerProvider = ({ children }) => {
  const [banners, setBanners] = useState([]);
  const [loadingBanners, setLoadingBanners] = useState(true);
  const [bannersError, setBannersError] = useState(null);

  const fetchBanners = async () => {
    try {
      setLoadingBanners(true);
      setBannersError(null);
      
      const res = await axios.get('http://localhost:3000/api/banner/fetch-banners', {
        withCredentials: true
      });
      
      console.log('Raw banner data:', res.data);
      
      const now = new Date();
      
      // Simple filtering - just get banners that are in date range
      let validBanners = res.data.filter(banner => {
        const startDate = new Date(banner.startDate);
        const endDate = new Date(banner.endDate);
        const isInDateRange = startDate <= now && endDate >= now;
        
        console.log(`Banner ${banner._id}:`, {
          startDate: startDate.toDateString(),
          endDate: endDate.toDateString(),
          now: now.toDateString(),
          isInDateRange
        });
        
        return isInDateRange;
      });
      
      console.log('Valid banners in date range:', validBanners);
      
      // If no banners in date range, get default banners
      if (validBanners.length === 0) {
        validBanners = res.data.filter(banner => banner.isDefault);
        console.log('Using default banners:', validBanners);
      }
      
      // If still no banners, use all banners
      if (validBanners.length === 0) {
        validBanners = res.data;
        console.log('Using all banners:', validBanners);
      }
      
      // Extract image URLs
      const bannerImages = validBanners.map(banner => banner.image);
      console.log('Final banner images:', bannerImages);
      
      setBanners(bannerImages);
      
    } catch (error) {
      console.error("Error fetching banners:", error);
      setBannersError(error.message);
      
      // Set a default banner if there's an error
      setBanners(["/placeholder.svg"]);
    } finally {
      setLoadingBanners(false);
    }
  };

  useEffect(() => {
    fetchBanners();
  }, []);

  // Function to refetch banners (useful after adding/deleting banners)
  const refetchBanners = () => {
    console.log('Refetching banners from context...');
    fetchBanners();
  };

  return (
    <BannerContext.Provider value={{ 
      banners, 
      fetchBanners: refetchBanners,
      loadingBanners, 
      bannersError
    }}>
      {children}
    </BannerContext.Provider>
  );
};

AnouncementContext.jsx:
import React, { createContext, useState, useEffect } from 'react';
import axios from 'axios';

export const AnnouncementContext = createContext();

export const AnnouncementProvider = ({ children }) => {
  const [announcement, setAnnouncement] = useState('');
  const [loadingAnnouncement, setLoadingAnnouncement] = useState(true);
  const [announcementError, setAnnouncementError] = useState(null);

  useEffect(() => {
    const fetchAnnouncement = async () => {
      try {
        const res = await axios.get('http://localhost:3000/api/announcement/all');
        const now = new Date();
        const activeAnnouncements = res.data.filter(a => !a.isDefault && new Date(a.startDate) <= now && new Date(a.endDate) >= now);
        let currentText = '';
        if (activeAnnouncements.length > 0) {
          currentText = activeAnnouncements[0].text; // Assume no overlaps, take first
        } else {
          const defaultAnnouncement = res.data.find(a => a.isDefault);
          if (defaultAnnouncement) {
            currentText = defaultAnnouncement.text;
          }
        }
        setAnnouncement(currentText);
        setAnnouncementError(null);
      } catch (error) {
        setAnnouncementError('Error fetching announcement');
        console.error(error);
      } finally {
        setLoadingAnnouncement(false);
      }
    };
    fetchAnnouncement();
  }, []);

  return (
    <AnnouncementContext.Provider value={{ announcement, loadingAnnouncement, announcementError }}>
      {children}
    </AnnouncementContext.Provider>
  );
};

App.jsx:
import { useState } from 'react';
import './App.css';
import { Routes, Route } from 'react-router-dom';
import Signup from './pages/client/Signup';
import Login from './pages/client/Login';
import AdminPanel from './pages/admin/AdminPanel';
import Home from './pages/client/Home';
import Orders from './pages/client/Orders';
import OrdersPanel from './components/admin/SidebarLinks/orders/OrdersPanel';
import ProtectedRoute from './protectedRoutes';


function App() {
  return (
      <Routes>
        <Route path='/auth/signup' element={<Signup />} />
        <Route path='/auth/login' element={<Login />} />
        <Route path='/admin/panel/*' element={
          <ProtectedRoute allowedRole="admin">
            <AdminPanel />
          </ProtectedRoute>
          } />
        <Route path='/' element={
            <ProtectedRoute allowedRole="user">
              <Home />
            </ProtectedRoute>
          } />
        <Route path='/orders/:userId' element={
            <ProtectedRoute allowedRole="user">
              <Orders />
            </ProtectedRoute>
          } />
          
        
        <Route path='/admin' element={<OrdersPanel />} />
      </Routes>
  );
}

export default App;


main.jsx:
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
import { BrowserRouter } from 'react-router-dom'
import { AuthProvider } from '../Context/AuthContext.jsx'
import { ProductProvider } from '../Context/ProductContext.jsx'
import { CartProvider } from '../Context/CartContext.jsx'
import { UserProvider } from '../Context/UserContext.jsx'
import ConditionalProvider from './ConditionalProvider.jsx'

createRoot(document.getElementById('root')).render(
  <BrowserRouter>
      <AuthProvider>
        <ConditionalProvider>
    <App />
        </ConditionalProvider>
        </AuthProvider>
  </BrowserRouter>,
)


ConditionalProvider.jsx:
import { useContext } from 'react';
import { AuthContext } from '../Context/AuthContext';
import { ProductProvider } from '../Context/ProductContext';
import { CartProvider } from '../Context/CartContext';
import { UserProvider } from '../Context/UserContext';
import { CategoryProvider } from '../Context/CategoryContext';
import { DiscountProvider } from '../Context/DiscountContext';
import { BannerProvider } from '../Context/BannerContext';
import { AnnouncementProvider } from '../Context/AnnouncementContext';
import { FreeCashProvider } from '../Context/FreeCashContext';

// import User from '../../backend/models/User';

const ConditionalProvider = ({children}) => {
    const { user } = useContext(AuthContext);

    if(user?.role === "admin") {
        return(
            
            <ProductProvider>
                <FreeCashProvider>
                <UserProvider>
                    <CategoryProvider>
                        <BannerProvider>
                    {children}
                        </BannerProvider>
                    </CategoryProvider>
                </UserProvider>
                </FreeCashProvider>
            </ProductProvider>
        );
    }

    return (
        <ProductProvider>
           <FreeCashProvider>
            <AnnouncementProvider>
            <BannerProvider>
                <DiscountProvider>
            <CartProvider>
                <CategoryProvider>
                {children}
                </CategoryProvider>
            </CartProvider>
            </DiscountProvider>
            </BannerProvider>
            </AnnouncementProvider>
            </FreeCashProvider>
        </ProductProvider>
    )
};

export default ConditionalProvider;

ProtectedRoutes.jsx:
import { useContext } from "react";
import { Navigate } from "react-router-dom";
import { AuthContext } from "../Context/AuthContext.jsx";

export default function ProtectedRoute({ children, allowedRole }) {
  const { user, loading } = useContext(AuthContext);

  if (loading) {
    return (
      <div className="fixed inset-0 bg-gray-100 flex items-center justify-center z-50">
        <div className="bg-white/80 backdrop-blur-sm rounded-lg p-8 flex flex-col items-center gap-3">
          <div className="w-12 h-12 border-4 border-blue-600 border-t-transparent rounded-full animate-spin" />
          <p className="text-gray-600 text-lg font-medium">Checking authentication...</p>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/auth/login" replace />;
  }

  // Role-based authorization
  if (allowedRole && user.role !== allowedRole) {
    // Redirect admins trying to access '/' to '/admin/admin'
    if (user.role === "admin" && allowedRole === "user") {
      return <Navigate to="/admin/panel" replace />;
    }
    // Redirect customers trying to access '/admin/admin' to '/'
    if (user.role === "user" && allowedRole === "admin") {
      return <Navigate to="/" replace />;
    }
  }

  return children;
}

Now this are the files and if you need more files then say me just say the fioles names
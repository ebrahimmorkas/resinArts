I am developing e-commerce website using MERN stack. I am placing the orders thriugh cart located in Home.jsx. When user login the user can add the products in the cart and chekcout the cart to place order and the order is placed successfully and the cart becomes empty. ---> All work well till here. Now the prolem is that (User am still logged in) when user again adds the products in the cart and clicks the chckout button to place the order then the error arises in the console of the browser. 
Error:
:3000/api/order/place-order:1  Failed to load resource: the server responded with a status of 400 (Bad Request)
hook.js:608 Checkout error: AxiosErrorcode: "ERR_BAD_REQUEST"config: {transitional: {…}, adapter: Array(3), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}message: "Request failed with status code 400"name: "AxiosError"request: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: true, upload: XMLHttpRequestUpload, …}response: config: {transitional: {…}, adapter: Array(3), transformRequest: Array(1), transformResponse: Array(1), timeout: 0, …}data: {success: false, message: 'No user ID provided'}headers: AxiosHeaders {content-length: '49', content-type: 'application/json; charset=utf-8'}request: XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 0, withCredentials: true, upload: XMLHttpRequestUpload, …}status: 400statusText: "Bad Request"[[Prototype]]: Objectstatus: 400stack: "AxiosError: Request failed with status code 400\n    at settle (http://localhost:5173/node_modules/.vite/deps/axios.js?v=6a9a1269:1232:12)\n    at XMLHttpRequest.onloadend (http://localhost:5173/node_modules/.vite/deps/axios.js?v=6a9a1269:1564:7)\n    at Axios.request (http://localhost:5173/node_modules/.vite/deps/axios.js?v=6a9a1269:2122:41)\n    at async handleCartCheckout (http://localhost:5173/src/pages/client/Home.jsx?t=1757393262048:74:19)"[[Prototype]]: Error
overrideMethod @ hook.js:608

I will provide you certain files:

CartContext.js:
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import axios from "axios";
import { FreeCashContext } from "./FreeCashContext";
import { ProductContext } from "./ProductContext";

const CartContext = createContext();

export const useCart = () => {
    const context = useContext(CartContext);
    if (!context) {
        throw new Error("useCart must be used within a CartProvider");
    }
    return context;
};

export const CartProvider = ({ children }) => {
    const [cartItems, setCartItems] = useState({});
    const [isCartOpen, setIsCartOpen] = useState(false);
    const [applyFreeCash, setApplyFreeCash] = useState(false);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const { freeCash } = useContext(FreeCashContext);
    const { products } = useContext(ProductContext);

    axios.defaults.withCredentials = true;

    useEffect(() => {
        fetchCartFromBackend();
    }, []);

    // Recalculate cash applied when applyFreeCash changes
    useEffect(() => {
        if (freeCash && Object.keys(cartItems).length > 0) {
            updateAllCashApplied();
        }
    }, [applyFreeCash, freeCash]);

    const fetchCartFromBackend = async () => {
        try {
            setLoading(true);
            const response = await axios.get("http://localhost:3000/api/cart", {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
            });

            if (response.status === 200) {
                const cartData = response.data;
                const formattedCart = {};
                cartData.forEach((item) => {
                    const cartKey = `${item.product_id}-${item.variant_name || "default"}-${item.size || "default"}`;
                    formattedCart[cartKey] = {
                        productId: item.product_id,
                        variantName: item.variant_name || null,
                        sizeString: item.size || null,
                        quantity: item.quantity,
                        price: item.price,
                        discountedPrice: item.discounted_price,
                        imageUrl: item.image_url,
                        productName: item.product_name,
                        variantId: item.variant_id,
                        detailsId: item.details_id,
                        sizeId: item.size_id,
                        cashApplied: item.cash_applied || 0,
                        userId: item.user_id,
                    };
                });
                setCartItems(formattedCart);
            }
        } catch (err) {
            setError("Failed to load cart");
            console.error("Error fetching cart:", err);
        } finally {
            setLoading(false);
        }
    };

    const addToCart = async (productId, colorName, sizeString, quantity, productData) => {
        try {
            setLoading(true);
            const cartKey = `${productId}-${colorName || "default"}-${sizeString || "default"}`;

            let cashApplied = 0;
            if (applyFreeCash && freeCash) {
                const product = products.find((p) => p._id === productId);
                if (product) {
                    const mockCartData = {
                        ...productData,
                        quantity: quantity,
                        discountedPrice: productData.discountedPrice || productData.price
                    };
                    
                    if (isFreeCashEligible(product, mockCartData, freeCash)) {
                        const itemTotal = mockCartData.discountedPrice * quantity;
                        cashApplied = Math.min(freeCash.amount, itemTotal);
                    }
                }
            }

            const cartItemData = {
                image_url: productData.imageUrl,
                product_id: productId,
                product_name: productData.productName,
                quantity: quantity,
                price: productData.price,
                cash_applied: cashApplied,
                discounted_price: productData.discountedPrice || productData.price,
            };

            if (productData.variantId && productData.variantId !== "") {
                cartItemData.variant_id = productData.variantId;
            }
            if (productData.detailsId && productData.detailsId !== "") {
                cartItemData.details_id = productData.detailsId;
            }
            if (productData.sizeId && productData.sizeId !== "") {
                cartItemData.size_id = productData.sizeId;
            }
            if (colorName && colorName !== "") {
                cartItemData.variant_name = colorName;
            }
            if (sizeString && sizeString !== "") {
                cartItemData.size = sizeString;
            }

            const response = await axios.post("http://localhost:3000/api/cart", cartItemData, {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
            });

            if (response.status === 200 || response.status === 201) {
                setCartItems((prev) => ({
                    ...prev,
                    [cartKey]: {
                        productId,
                        variantName: colorName || null,
                        sizeString: sizeString || null,
                        quantity: (prev[cartKey]?.quantity || 0) + quantity,
                        price: productData.price,
                        discountedPrice: productData.discountedPrice || productData.price,
                        imageUrl: productData.imageUrl,
                        productName: productData.productName,
                        variantId: productData.variantId,
                        detailsId: productData.detailsId,
                        sizeId: productData.sizeId,
                        cashApplied,
                    },
                }));
            } else {
                throw new Error("Failed to add item to cart");
            }
        } catch (err) {
            setError("Failed to add item to cart");
            console.error("Error adding to cart:", err);
        } finally {
            setLoading(false);
        }
    };

    const updateQuantity = async (cartKey, change) => {
        try {
            const item = cartItems[cartKey];
            if (!item) return;

            const newQuantity = item.quantity + change;

            if (newQuantity <= 0) {
                await removeFromCart(cartKey);
                return;
            }

            let cashApplied = 0;
            if (applyFreeCash && freeCash) {
                const product = products.find((p) => p._id === item.productId);
                if (product) {
                    const mockCartData = {
                        ...item,
                        quantity: newQuantity,
                        discountedPrice: item.discountedPrice || item.price
                    };
                    
                    if (isFreeCashEligible(product, mockCartData, freeCash)) {
                        const itemTotal = mockCartData.discountedPrice * newQuantity;
                        cashApplied = Math.min(freeCash.amount, itemTotal);
                    }
                }
            }

            const response = await axios.put(
                "http://localhost:3000/api/cart",
                {
                    product_id: item.productId,
                    variant_name: item.variantName,
                    size: item.sizeString,
                    quantity: newQuantity,
                    cash_applied: cashApplied,
                },
                {
                    withCredentials: true,
                    headers: {
                        "Content-Type": "application/json",
                    },
                },
            );

            if (response.status === 200) {
                setCartItems((prev) => ({
                    ...prev,
                    [cartKey]: {
                        ...prev[cartKey],
                        quantity: newQuantity,
                        cashApplied,
                    },
                }));
            }
        } catch (err) {
            setError("Failed to update quantity");
            console.error("Error updating quantity:", err);
        }
    };

    const removeFromCart = async (cartKey) => {
        try {
            const item = cartItems[cartKey];
            if (!item) return;

            const response = await axios.delete("http://localhost:3000/api/cart", {
                withCredentials: true,
                headers: {
                    "Content-Type": "application/json",
                },
                data: {
                    product_id: item.productId,
                    variant_name: item.variantName,
                    size: item.sizeString,
                },
            });

            if (response.status === 200) {
                setCartItems((prev) => {
                    const newCart = { ...prev };
                    delete newCart[cartKey];
                    return newCart;
                });
            }
        } catch (err) {
            setError("Failed to remove item");
            console.error("Error removing from cart:", err);
        }
    };

    const isFreeCashEligible = (product, item, freeCash) => {
        if (!freeCash) return false;

        const now = new Date();
        if (
            freeCash.is_cash_used ||
            freeCash.is_cash_expired ||
            now < new Date(freeCash.start_date) ||
            now > new Date(freeCash.end_date)
        ) {
            return false;
        }

        // Use correct property name
        const itemPrice = item.discountedPrice || item.price;
        const itemTotal = itemPrice * item.quantity;
        
        if (itemTotal < freeCash.valid_above_amount) {
            return false;
        }

        if (freeCash.is_cash_applied_on__all_products) {
            return true;
        }

        // Check category restrictions
        if (freeCash.category) {
            const isMainCategoryMatch = product.mainCategory && 
                (product.mainCategory.toString() === freeCash.category.toString() ||
                 product.mainCategory._id?.toString() === freeCash.category.toString());
            
            if (!isMainCategoryMatch) {
                return false;
            }

            if (freeCash.sub_category) {
                const isSubCategoryMatch = product.subCategory &&
                    (product.subCategory.toString() === freeCash.sub_category.toString() ||
                     product.subCategory._id?.toString() === freeCash.sub_category.toString());
                
                if (!isSubCategoryMatch) {
                    return false;
                }
            }
        }

        return true;
    };

    // Update cash applied for all items when applyFreeCash changes
    const updateAllCashApplied = async () => {
        const updatedItems = {};
        let hasChanges = false;

        for (const [cartKey, item] of Object.entries(cartItems)) {
            let cashApplied = 0;
            
            if (applyFreeCash && freeCash) {
                const product = products.find((p) => p._id === item.productId);
                if (product && isFreeCashEligible(product, item, freeCash)) {
                    const itemTotal = (item.discountedPrice || item.price) * item.quantity;
                    cashApplied = Math.min(freeCash.amount, itemTotal);
                }
            }

            if (cashApplied !== item.cashApplied) {
                hasChanges = true;
                updatedItems[cartKey] = { ...item, cashApplied };

                // Update on backend
                try {
                    await axios.put(
                        "http://localhost:3000/api/cart",
                        {
                            product_id: item.productId,
                            variant_name: item.variantName,
                            size: item.sizeString,
                            quantity: item.quantity,
                            cash_applied: cashApplied,
                        },
                        {
                            withCredentials: true,
                            headers: {
                                "Content-Type": "application/json",
                            },
                        }
                    );
                } catch (error) {
                    console.error("Error updating cash applied for item:", error);
                }
            } else {
                updatedItems[cartKey] = item;
            }
        }

        if (hasChanges) {
            setCartItems(updatedItems);
        }
    };

    const getCartTotal = () => {
        let total = Object.values(cartItems).reduce((sum, item) => {
            const price = item.discountedPrice || item.price;
            return sum + price * item.quantity;
        }, 0);

        let totalFreeCashApplied = 0;
        if (applyFreeCash && freeCash) {
            totalFreeCashApplied = Object.values(cartItems).reduce((sum, item) => {
                const product = products.find((p) => p._id === item.productId);
                if (product && isFreeCashEligible(product, item, freeCash)) {
                    return sum + (item.cashApplied || 0);
                }
                return sum;
            }, 0);
        }

        return Math.max(0, total - totalFreeCashApplied);
    };

    const getUniqueCartItemsCount = () => {
        return Object.keys(cartItems).length;
    };

    const getTotalItemsCount = () => {
        return Object.values(cartItems).reduce((sum, item) => sum + item.quantity, 0);
    };

    const clearCart = async () => {
    try {
        setLoading(true);
        // Clear cart on backend
        const response = await axios.delete("http://localhost:3000/api/cart/clear", {
            withCredentials: true,
            headers: {
                "Content-Type": "application/json",
            },
        });

        if (response.status === 200) {
            // Clear cart on frontend
            setCartItems({});
            setApplyFreeCash(false); // Reset free cash checkbox
        }
    } catch (err) {
        setError("Failed to clear cart");
        console.error("Error clearing cart:", err);
    } finally {
        setLoading(false);
    }
};

    const value = {
    cartItems,
    isCartOpen,
    setIsCartOpen,
    applyFreeCash,
    setApplyFreeCash,
    loading,
    error,
    addToCart,
    updateQuantity,
    removeFromCart,
    getCartTotal,
    getUniqueCartItemsCount,
    getTotalItemsCount,
    fetchCartFromBackend,
    clearCart,
};

    return <CartContext.Provider value={value}>{children}</CartContext.Provider>
};

cartRoutes.js:
const express = require("express")
const Cart = require("../models/Cart") // Adjust path as needed
const router = express.Router()

// Middleware to check authentication
const requireAuth = (req, res, next) => {
  if (!req.user || !req.user.id) {
    return res.status(401).json({ error: "Authentication required" })
  }
  next()
}

// Apply authentication middleware to all routes
router.use(requireAuth)

// GET /api/cart - Fetch all cart items for user
router.get("/", async (req, res) => {
  try {
    const cartItems = await Cart.find({ user_id: req.user.id })
    res.status(200).json(cartItems)
  } catch (error) {
    console.error("Error fetching cart:", error)
    res.status(500).json({ error: "Failed to fetch cart items" })
  }
})

// POST /api/cart - Add item to cart
router.post("/", async (req, res) => {
  try {
    const {
      image_url,
      product_id,
      variant_id,
      details_id,
      size_id,
      product_name,
      variant_name,
      size,
      quantity,
      price,
      cash_applied,
      discounted_price,
    } = req.body

    const existingItem = await Cart.findOne({
      user_id: req.user.id,
      product_id,
      variant_name: variant_name || null,
      size: size || null,
    })

    if (existingItem) {
      // Update quantity if item exists
      existingItem.quantity += quantity
      await existingItem.save()
      res.status(200).json(existingItem)
    } else {
      const cartItemData = {
        user_id: req.user.id,
        image_url,
        product_id,
        product_name,
        quantity,
        price,
        cash_applied,
        discounted_price,
      }

      // Only add variant fields if they exist
      if (variant_id) cartItemData.variant_id = variant_id
      if (details_id) cartItemData.details_id = details_id
      if (size_id) cartItemData.size_id = size_id
      if (variant_name) cartItemData.variant_name = variant_name
      if (size) cartItemData.size = size

      const newCartItem = new Cart(cartItemData)
      await newCartItem.save()
      res.status(201).json(newCartItem)
    }
  } catch (error) {
    console.error("Error adding to cart:", error)
    res.status(500).json({ error: "Failed to add item to cart" })
  }
})

// PUT /api/cart - Update item quantity
router.put("/", async (req, res) => {
  try {
    const { product_id, variant_name, size, quantity } = req.body

    const cartItem = await Cart.findOneAndUpdate(
      {
        user_id: req.user.id,
        product_id,
        variant_name,
        size,
      },
      { quantity },
      { new: true },
    )

    if (!cartItem) {
      return res.status(404).json({ error: "Cart item not found" })
    }

    res.status(200).json(cartItem)
  } catch (error) {
    console.error("Error updating cart:", error)
    res.status(500).json({ error: "Failed to update cart item" })
  }
})

// DELETE /api/cart - Remove item from cart
router.delete("/", async (req, res) => {
  try {
    const { product_id, variant_name, size } = req.body

    const deletedItem = await Cart.findOneAndDelete({
      user_id: req.user.id,
      product_id,
      variant_name,
      size,
    })

    if (!deletedItem) {
      return res.status(404).json({ error: "Cart item not found" })
    }

    res.status(200).json({ message: "Item removed from cart" })
  } catch (error) {
    console.error("Error removing from cart:", error)
    res.status(500).json({ error: "Failed to remove item from cart" })
  }
})

// DELETE /api/cart/clear - Clear entire cart
router.delete("/clear", async (req, res) => {
  try {
    await Cart.deleteMany({ user_id: req.user.id })
    res.status(200).json({ message: "Cart cleared successfully" })
  } catch (error) {
    console.error("Error clearing cart:", error)
    res.status(500).json({ error: "Failed to clear cart" })
  }
})

module.exports = router

Cart.js:
const mongoose = require("mongoose");

const cartSchema = mongoose.Schema(
    {
        user_id: {
            type: mongoose.Schema.Types.ObjectId,
            required: true,
        },
        image_url: {
            type: String,
            required: true,
        },
        product_id: {
            type: mongoose.Schema.Types.ObjectId,
            required: true,
        },
        variant_id: {
            type: mongoose.Schema.Types.ObjectId,
            required: false,
            default: null,
        },
        details_id: {
            type: mongoose.Schema.Types.ObjectId,
            required: false,
            default: null,
        },
        size_id: {
            type: mongoose.Schema.Types.ObjectId,
            required: false,
            default: null,
        },
        product_name: {
            type: String,
            required: true,
        },
        variant_name: {
            type: String,
            required: false,
            default: null,
        },
        size: {
            type: String,
            required: false,
            default: null,
        },
        quantity: {
            type: Number,
            required: true,
            min: 1,
        },
        price: {
            type: Number,
            required: true,
            min: 1,
        },
        cash_applied: {
            type: Number,
            required: false,
            default: 0,
        },
        discounted_price: {
            type: Number,
            required: true,
        },
    },
    {
        timestamps: true,
    },
);

module.exports = mongoose.model("Cart", cartSchema);

orderController.js:
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail');
const FreeCash = require('../models/FreeCash');
// const sendEmail = require('../utils/sendEmail');

// Function to check whether the order exists or not
const findOrder = async (orderId) => {
    try {
        const order = await Order.findById(orderId);
        if(order) {
            return order;
        } else {
            return null;
        }
    } catch (error) {
        throw error;
    }
}

const findUser = async (userId) => {
    const user = await User.findById(userId);
    if(user) {
        return user;
    } else {
        return null;
    }
}

const findProduct = async (productId) => {
    const product = await Product.findById(productId);
    if(product) {
        return product;
    } else {
        return null;
    }
}

// Function to add the order
const placeOrder = async (req, res) => {
    try {
        const cartItems = Object.values(req.body);
        if (!cartItems || cartItems.length === 0) {
            return res.status(400).json({
                success: false,
                message: "Cart is empty",
            });
        }

        const userId = cartItems[0]?.userId;
        if (!userId) {
            return res.status(400).json({
                success: false,
                message: "No user ID provided",
            });
        }

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found",
            });
        }

        const errors = [];
        const ordersToAdd = [];
        let totalFreeCashApplied = 0;
        let freeCashId = null;

        const freeCash = await FreeCash.findOne({
            user_id: userId,
            is_cash_used: false,
            is_cash_expired: false,
            start_date: { $lte: new Date() },
            end_date: { $gte: new Date() },
        });

        for (const cartData of cartItems) {
            try {
                const product = await Product.findById(cartData.productId);
                if (!product) {
                    errors.push(`Product not found for id ${cartData.productId}`);
                    continue;
                }

                let cashApplied = cartData.cash_applied || cartData.cashApplied || 0;
                if (freeCash && cashApplied > 0) {
                    const isEligible = isFreeCashEligible(product, cartData, freeCash);
                    if (!isEligible) {
                        errors.push(`Free cash not eligible for product ${cartData.productName}`);
                        cashApplied = 0;
                    } else {
                        totalFreeCashApplied += cashApplied;
                        freeCashId = freeCash._id;
                    }
                }

                if (cartData.variantId) {
                    const variant = product.variants.find((v) => v._id.toString() === cartData.variantId);
                    if (!variant) {
                        errors.push(`Variant ${cartData.variantName || 'Unknown'} not found for product ${cartData.productName}`);
                        continue;
                    }

                    if (!cartData.sizeId) {
                        errors.push(`Size is required for variant ${cartData.variantName} of product ${cartData.productName}`);
                        continue;
                    }

                    let sizeFound = false;
                    for (const variantItem of product.variants) {
                        if (variantItem._id.toString() === cartData.variantId) {
                            for (const detail of variantItem.moreDetails) {
                                if (
                                    detail._id.toString() === cartData.detailsId &&
                                    detail.size._id.toString() === cartData.sizeId
                                ) {
                                    sizeFound = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!sizeFound) {
                        errors.push(`Size ${cartData.sizeString || 'Unknown'} not found in variant ${cartData.variantName} for product ${cartData.productName}`);
                        continue;
                    }

                    ordersToAdd.push({
                        image_url: cartData.imageUrl,
                        product_id: cartData.productId,
                        product_name: cartData.productName,
                        variant_id: cartData.variantId,
                        variant_name: cartData.variantName,
                        size_id: cartData.sizeId,
                        size: cartData.sizeString,
                        quantity: cartData.quantity,
                        price: cartData.price,
                        total: cartData.price * cartData.quantity,
                        cash_applied: cashApplied,
                    });
                } else {
                    ordersToAdd.push({
                        image_url: cartData.imageUrl,
                        product_id: cartData.productId,
                        product_name: cartData.productName,
                        quantity: cartData.quantity,
                        price: cartData.price,
                        total: cartData.price * cartData.quantity,
                        cash_applied: cashApplied,
                    });
                }
            } catch (itemError) {
                console.error('Error processing cart item:', itemError);
                errors.push(`Error processing product ${cartData.productId}: ${itemError.message}`);
                continue;
            }
        }

        if (ordersToAdd.length > 0) {
            const totalPrice = ordersToAdd.reduce((sum, item) => sum + item.total, 0);
            const finalPrice = Math.max(0, totalPrice - totalFreeCashApplied);

            const orderData = {
                user_id: req.user.id,
                user_name: `${user.first_name} ${user.middle_name || ''} ${user.last_name}`.trim(),
                email: user.email,
                phone_number: user.phone_number,
                whatsapp_number: user.whatsapp_number,
                orderedProducts: ordersToAdd,
                price: finalPrice,
            };

            if (totalFreeCashApplied > 0 && freeCashId) {
                orderData.cash_applied = { amount: totalFreeCashApplied, freeCashId };
                await FreeCash.findByIdAndUpdate(freeCashId, { is_cash_used: true, cash_used_date: new Date() });
                try {
                    await sendEmail(
                        user.email,
                        "Free Cash Applied",
                        `Your free cash of $${totalFreeCashApplied} has been applied to your order. Note: Free cash is single-use and any remaining amount is not credited back.`
                    );
                } catch (emailError) {
                    console.error("Error sending free cash email:", emailError);
                }
            }

            const newOrder = new Order(orderData);
            await newOrder.save();

            return res.status(201).json({
                success: true,
                message: "Order placed successfully",
                order: {
                    id: newOrder._id,
                    totalPrice: finalPrice,
                    itemCount: ordersToAdd.length,
                    validItems: ordersToAdd.length,
                    totalItems: cartItems.length,
                },
                warnings: errors.length > 0 ? {
                    message: `${errors.length} items could not be processed`,
                    details: errors,
                } : undefined,
            });
        } else {
            return res.status(400).json({
                success: false,
                message: "No valid items to order. All items have errors.",
                errors: errors,
            });
        }
    } catch (error) {
        console.error('Order placement error:', error);
        return res.status(500).json({
            success: false,
            message: "Internal server error while placing order",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined,
        });
    }
};

// Function to fetch all the orders
const fetchOrders = async (req, res) => {
    console.log("Request received for fetching orders");
    try {
        const orders = await Order.find();
        if(orders) {
            // console.log(orders);
            return res.status(200).json({message: "Success", orders});
        } else {
            return res.status(400).json({message: "No orders found"});
        }
    } catch(error) {
        return res.status(500).json({message: "Internal server error"});
    }
};

// Function where admin will update the shiping price
const shippingPriceUpdate = async (req, res) => {
    // console.log(req.body);
    try {
        const {shippingPriceValue, orderId, email} = req.body;
        const order = await Order.findById(orderId);
        if(order) {
            // Order with this ID is present
            console.log(order)
            // Checking the input
            if(parseInt(shippingPriceValue) > 0) {
                // Input is proper

                // Updating the order
                try {
                    const totalPrice = order.price + parseInt(shippingPriceValue);
                    const updatedOrder = await Order.findByIdAndUpdate(
                        orderId,
                         {
                            shipping_price: shippingPriceValue,
                            total_price: totalPrice,
                            status: "Accepted",
                        },
                    
                    {
                        new: true,
                        runValidators: true
                    }
                    );
                    // console.log(email)
                    try {
                        await sendEmail(email, "Accepted", `Your order has been accepted for id ${orderId}`)
                    } catch(error) {
                        console.log("Error in sending email");
                    } finally {
                        return res.status(200).json({message: "Shipping price updated"});
                    }
                } catch(error) {
                    // Prolem while updating the order
                    return res.status(400).json({message: "Problem while updating the order"});
                }
            } else {
                // Input is not proper
                return res.status(400).json({message: "Input is not proper"})
            }
        } else {
            // Order with this id is not present
            return res.status(400).json({message: "Product not found"})
        }
    } catch(error) {
        return res.status(500).json({message: `Internal server error ${error}`});
    }
}

// Function to handle status
const handleStatusChange = async (req, res) => {
    // console.log(req.body);
    try {
    const {status, orderId} = req.body;

    const statuses = ["Accepted", "Rejected", "In-Progress", "Dispatched", "Completed", "Pending", "Confirm"];

    // Check whether the received status is valid
    if(statuses.includes(status)) {

    // Checking whether the order exists or not
    const order = await findOrder(orderId);
    // checking whether user exists or not
    const user = await findUser(order.user_id)
    if(order) {
        // Order is present

        // Checking whether user exists or not
        if(user) {
            console.log("Updting")
            // Start the updating process
            let paymentStatus = "Payment Pending";
            if(status === "Confirm") {
                paymentStatus = "Paid"
            }
            const updatedOrder = await Order.findByIdAndUpdate(
                orderId,
                {
                    status: status, 
                    payment_status: paymentStatus
                },
                {
                    new: true,
                    runValidators: true
                }
            )

            // Sending the email
            try {
                // console.log("try email")
                switch(status) {
                    case "Rejected":
                    sendEmail(user.email, status, `Unfortunately, Your order with ${orderId} has been rejected`);
                    break;

                    case "Confirm":
                        sendEmail(user.email, status, `We have successfully received your payment for order ${orderId}. Your order will be delivered soon`);
                        break;
                    
                        case "Dispatched":
                            sendEmail(user.email, status, `Your order ${orderId} has been successfully dispatched`);
                            break;
                }
            } catch (error) {
                // console.log("catch email")
                console.log("Error in sending email");
            } finally {
                // console.log("Finally email")
                return res.status(200).json({message: "Rejected successfully"});
            }
        } else {
            // User does not exist
            return res.status(400).json({message: "User not found"})
        }
    } else {
        // Order is not present
        return res.status(400).json({message: "Order not found"})        
    }
} else {
    return res.status(400).json({message: "Invalid status"});
}
} catch(error) {
    return res.status(500).json({message: "Internal server error"});
}
}

// Function to edit the order that is quantity and price
const editOrder = async (req, res) => {
    // console.log(req.body);
    try {
        const {products} = req.body;
        const {orderId} = req.params;
        const order = await findOrder(orderId);
        const user = await findUser(order.user_id);
        if(order) {
            console.log(products[0]);
            if(user) {
                const prices = [];
                for (const prod of products) {
                    const product = await findProduct(prod.product_id);
                    if(!product) {
                        return res.status(400).json({message: "Product not found"})
                    } else {
                        prices.push(prod.total);
                    }
                }
                const price = prices.reduce((accumulator, current) => accumulator + current, 0);
                const totalPrice = price + order.shipping_price;
                try {
                    const updatedProduct = await Order.findByIdAndUpdate(
                        order._id,
                        {
                            orderedProducts: products,
                            price: price,
                            total_price: totalPrice
                        },
                        {
                            new: true,
                            runValidators: true
                        }
                    );

                    try {
                        // console.log("Sending email");
                        sendEmail(user.email, `Updation of order ${order._id}`, `Your total price is ${updatedProduct.total_price}`);
                    } catch(error) {
                        console.log("Problem in sending email");
                    } finally {
                        return res.status(200).json({message: "Product edited successfully"});
                    }
                } catch(error) {
                    return res.status(400).json({message: `Problem while updating the order ${error}`});
                }
            } else {
                return res.status(400).json({message: "User not found"});
            }
        } else {
            return res.status(400).json({message: "Order not found"});
        }
    } catch (error) {
        return res.status(500).json({message: "Internal server error"});
    }
}

const isFreeCashEligible = (product, cartData, freeCash) => {
    if (!freeCash) return false;
    
    const now = new Date();
    if (
        freeCash.is_cash_used ||
        freeCash.is_cash_expired ||
        now < new Date(freeCash.start_date) ||
        now > new Date(freeCash.end_date)
    ) {
        return false;
    }

    // Calculate item total - use correct property names
    const itemPrice = cartData.discountedPrice || cartData.price;
    const itemTotal = itemPrice * cartData.quantity;
    
    if (itemTotal < freeCash.valid_above_amount) {
        return false;
    }

    // If applicable to all products
    if (freeCash.is_cash_applied_on__all_products) {
        return true;
    }

    // Check category restrictions
    if (freeCash.category) {
        // Compare with product's mainCategory
        const isMainCategoryMatch = product.mainCategory && 
            (product.mainCategory.toString() === freeCash.category.toString() ||
             product.mainCategory._id?.toString() === freeCash.category.toString());
        
        if (!isMainCategoryMatch) {
            return false;
        }

        // If sub_category is specified, check it too
        if (freeCash.sub_category) {
            const isSubCategoryMatch = product.subCategory &&
                (product.subCategory.toString() === freeCash.sub_category.toString() ||
                 product.subCategory._id?.toString() === freeCash.sub_category.toString());
            
            if (!isSubCategoryMatch) {
                return false;
            }
        }
    }

    return true;
};
module.exports = {
    placeOrder,
    fetchOrders,
    shippingPriceUpdate,
    handleStatusChange,
    editOrder,
    isFreeCashEligible,
};

This are the files I have provided you now if you want more additional files then just say me the names of the files you need without any hesitation. I will provide you all the files. If you need files then dont generate any content first say the files names.

Okay lets start.

I want to create the form for Adding Product named it as AddProduct.jsx.
It should contain the following:

The form should be divided into two sections:
1. Basic Information section
2. Product Variant Sections (Admin should be able to add multiple)

Now In the basic information section include :-
Name
Category :-
For this include two dropdowns side by side. First for the main category and then second for the sub category. When user selects the main category then all the sub categories of the main category should be displayed in this second dropdown. Then if this selected sub category of the main category again has the sub categories then that values should be displayed in this second dropdown of categories. Below this show the category path. That means I have nested category for eg main category is Electronics inside it mobiles inside mobiles again two categories vivo and oppo and inside vivo there is sub category v11 and inside oppo there is sub category o11. This categories need to fetched from the backend. I will later provide you the necessary files for fetching the categories.
product details :- This should be in the manner of key value pair. Admin should be able to as many he want and can delete as well.
Stock 
Price
Image
Additional Images :- This is also section that admin can create as many he wants that is admin will upload the image of the product now he want to add multiple views of the product so that images will be added in the additional images section.
Bulk pricing section :- Admin should be able to create multiple Bulk pricing section. This section should contain the following fields:
Wholesale price :- This should be less than the price which is entered above.
Quantity :- For this field show bold message that this will be included

This completes the Basic Information section. Above the fields show message that Fill below fields only if you dont have any product variants. Display this message in very eye catching manner. Now if user enters data in either price, stock, image fields this Product Variants section shoud be hidden and vice versa is that if user enters data in any field inside this section then the price, stock, image fileds should be hidden. 

Product variant Section:-
It should include the following:
Color name
Variant image
Optional Details :- Admin should be able to add multiple sections of optioals details as well. This should be in the form of key value pairs as well. (optional)
More details section (Starts here)
Sizes section :- The admin should be able to add multiple sizes section and can delete as well. It should include the following fields:
      Length
      Breadth
      Height
      Dropdown - include values such as (cm, m, inch)
Out of lenght breadth and height only two should be required not all.
Additional Images section :- Same, as in basic information section that is user should be able to add multiple images for the product variant (Optional).
Optional Details for this size :- Again, can be added multiple times and optional
(more details section ends here)

Now these sizes, additional images, optional details for this more details section, These all three sections should be replicated when user clicks on 'Add more detail section' button means additional images, optional products and size as well are associated with the more details section in the product variant rather than variant itself for eg:
red color 12 X 12 X 12 size and red color 13 X 13 X 13 size can have different additional images and optional details for this more detail section and same optional details (This one is variant specific).

Now if user adds the another more detail section so again these three sections that is size, additional images, optional details for this more detail section will be replicated. So if there are more 'more details section'  section then one that means user may have aded additional images and optional details for previous more details section so in the next more detailn section, in the additional images section user should be provided dropdown asking 'Do you want to reuse additional images?'  display options yes and no. 
If user selects yes then in the dropdown show options such as color name + size entered in the size section of the more detail section in which the additional images are being added and then again display the image field if user wants to add more in coninuation from the previous one and this image field can be created muultiple times . And if user selecs no then directly display images fields where user can add images and this section can be created muultiple times 
Same process for optional details for this size.

for eg user has created 3 more detail section in which user has added additional images for the first more detail section. When second and third more detail sections were added the admin reused the additional images and optional details. Now user added 4th more detail section and added different additional images and optional detials. Now admin added 5th more details section and while adding additional images the admin selected yes so now he should be only displayed two options that is red 12 X 12 X 12 (Color name and size of the first more detailed section) and second option that is red 14 X 14 X 14 (color name and size of the 4th more detailed section) that means the more detailed s4ction that are simply reusing additional imags and optional details should not be listed. NOTE:- Additional images and optional details should be indepenedent of each other means if admin is reusing additional images so he can add the optional details for this more detail section, if he is reusing addditional images that does not mean he will not reuse the optional details for this more detail section and vice versa.

now again entering the fields of product variants sections:-
price :- if user has created multiple more details section then display the dropdown saying 'is price same for all more details section' display option yes and no. If users selects yes then display only one filed for entering price and this price will be common for all more details section. Now if user selects no then display different price field for each more detail section for eg user selects no :- then display color name + size entered in that more details section and the price field. For eg there are 2 more details section named red 12 X 12 X 12 and red 13 X 13 X 13 
So it should be like:
red 12 X 12 X 12 price field
red 13 X 13 X 13 price field

stock :- Same as price logic

Bulk pricing combinations :- It will include the same fields as declated in the basic information section and the logic is same if price is common then only for one price user can create multiple bulk pricing sections and iof there are multiple price fields for the same variant then admin can create bulk pricing section for each price field and for each price user can add multiple bulk pricing section.

Now display add product button and add variant button as well. 
now if user has entered data in the price, image, or stock image so product variant section will be hidden and when user clicks on add variant section so all these fileds (price, stock, image, additional images) should be hidden and product variant section should be displayed but data inside that should not be lost but it should not be vice versa.

Files to implement Fetching of category. I have implemented nested category in my mongoDB.
Category.js :-
const mongoose = require('mongoose');




const categorySchema = mongoose.Schema({

  categoryName: {

    type: String,

    required: true,

    trim: true,

  },

  parent_category_id: {

    type: mongoose.Schema.Types.ObjectId,

    default: null,

    required: false,

    ref: 'Category',

  },

  image: {

    type: String, // Store Cloudinary image URL for main categories

    required: false,

  },

}, {

  timestamps: true,

});




// Index for faster queries on parent_category_id

categorySchema.index({ parent_category_id: 1 });




module.exports = mongoose.model('Category', categorySchema);

addCategoryController.js :-
const Category = require('../models/Category');

const { cloudinary } = require('../utils/cloudinary');

const multer = require('multer');




// Configure multer for in-memory storage

const storage = multer.memoryStorage();

const upload = multer({ storage });




const addCategory = async (req, res) => {

  console.log('Adding category request received:', JSON.stringify(req.body, null, 2));

  try {

    const { categories } = req.body;

    const imageFile = req.file;




    if (!categories) {

      console.log('Categories data is required');

      return res.status(400).json({ error: 'Categories data is required' });

    }




    // Parse categories if it's a string (from FormData)

    let parsedCategories;

    try {

      parsedCategories = JSON.parse(categories);

    } catch (error) {

      console.log('Invalid categories JSON format');

      return res.status(400).json({ error: 'Invalid categories JSON format' });

    }




    if (!Array.isArray(parsedCategories) || parsedCategories.length === 0) {

      console.log('Categories array is required');

      return res.status(400).json({ error: 'Categories array is required' });

    }




    if (!parsedCategories[0].categoryName) {

      console.log('Main category name is required');

      return res.status(400).json({ error: 'Main category name is required' });

    }




    let imageUrl = null;

    if (imageFile) {

      // Upload image to Cloudinary

      const uploadResult = await new Promise((resolve, reject) => {

        const uploadStream = cloudinary.uploader.upload_stream(

          { folder: 'categories' },

          (error, result) => {

            if (error) reject(error);

            else resolve(result);

          }

        );

        uploadStream.end(imageFile.buffer);

      });

      imageUrl = uploadResult.secure_url;

      console.log('Image uploaded to Cloudinary:', imageUrl);

    }




    // Validate that only main category can have an image

    for (const category of parsedCategories) {

      if (category.parent_category_id !== null && category.image) {

        console.log('Only main categories can have images');

        return res.status(400).json({ error: 'Only main categories can have images' });

      }

      if (category.image && !isValidUrl(category.image)) {

        console.log('Invalid image URL provided');

        return res.status(400).json({ error: 'Invalid image URL' });

      }

    }




    // Update main category with Cloudinary image URL

    if (imageUrl) {

      parsedCategories[0].image = imageUrl;

    }




    const savedCategoryIds = {};

    const savedCategories = [];




    for (const category of parsedCategories) {

      let parentId = null;




      if (category.parent_category_id) {

        console.log(`Processing parent_category_id: ${category.parent_category_id}`);




        if (category.parent_category_id === 'main') {

          parentId = savedCategoryIds['main'];

        } else {

          const pathKey = category.parent_category_id;

          if (!savedCategoryIds[pathKey]) {

            console.log(`Invalid parent_category_id: ${category.parent_category_id} (path: ${pathKey})`);

            return res.status(400).json({ error: `Invalid parent_category_id: ${category.parent_category_id}` });

          }

          parentId = savedCategoryIds[pathKey];

        }

      }




      console.log(`Saving category: ${category.categoryName}, parentId: ${parentId || 'null'}`);




      const newCategory = new Category({

        categoryName: category.categoryName,

        parent_category_id: parentId,

        image: category.image || null,

      });




      const saved = await newCategory.save();

      savedCategories.push(saved);




      if (category.parent_category_id === null) {

        savedCategoryIds['main'] = saved._id;

        console.log(`Saved main category: ${category.categoryName}, _id: ${saved._id}`);

      } else {

        const currentPath = category.current_path;

        if (currentPath) {

          savedCategoryIds[currentPath] = saved._id;

          console.log(`Saved subcategory: ${category.categoryName}, path: ${currentPath}, _id: ${saved._id}`);

        }

      }

    }




    res.status(201).json({

      message: 'Categories created successfully',

      categories: savedCategories,

    });

  } catch (error) {

    console.error('Error creating categories:', error.message);

    res.status(500).json({ error: 'Internal server error' });

  }

};




// Helper function to validate URL

const isValidUrl = (string) => {

  try {

    new URL(string);

    return true;

  } catch (_) {

    return false;

  }

};




// Export the controller wrapped with multer middleware

module.exports = {

  addCategory: [upload.single('image'), addCategory],

};

getAllCategoryController.js:-
// controllers/getAllCategoriesController.js

const Category = require('../models/Category');




const buildCategoryTree = (categories, parentId = null) => {

  return categories

    .filter(cat => String(cat.parent_category_id) === String(parentId))

    .map(cat => ({

      _id: cat._id,

      categoryName: cat.categoryName,

      image: cat.image || null,

      subcategories: buildCategoryTree(categories, cat._id)

    }));

};




const getAllCategories = async (req, res) => {

  try {

    const categories = await Category.find().lean();

    const tree = buildCategoryTree(categories);

    res.status(200).json(tree);

  } catch (error) {

    console.error("Error fetching categories:", error.message);

    res.status(500).json({ error: "Internal server error" });

  }

};




module.exports = getAllCategories;

categoryRoutes.js :-
const express = require('express');

const router = express.Router();

const { addCategory } = require('../controllers/addCategoryController');

const getAllCategories = require('../controllers/getAllCategoriesController');




router.post('/add', ...addCategory);

router.get('/all', getAllCategories);




module.exports = router;

the above files are fully tested and they are working means I can fetch the nested category as discussed above in basic information section

server.js:-
const express = require('express');

const mongoose = require('mongoose');

const cors = require('cors');

require('dotenv').config();

const cookieParser = require('cookie-parser');

const path = require('path');

const authRoutes = require('./routes/authRoutes');

const categoryRoutes = require('./routes/categoryRoutes');

const productRoutes = require('./routes/productRoutes');

const authenticate = require('./middlewares/authenticate');

const authorize = require('./middlewares/authorize');

const User = require('./models/User');

const morgan = require('morgan');




const app = express();




// Middleware

// app.use(morgan('dev')); // Request logging for debugging

app.use(express.json());

app.use(express.urlencoded({ extended: true }));

app.use(cookieParser());

app.use(

  cors({

    origin: process.env.FRONTEND_URL || 'http://localhost:5173', // Configurable frontend origin

    credentials: true, // Allow cookies

    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],

    allowedHeaders: ['Content-Type', 'Authorization'],

  })

);




// Serve static files for uploads

// app.use('/uploads', express.static(path.join(__dirname, 'Uploads')));




// MongoDB Connection

mongoose

  .connect(process.env.MONGO_URI)

  .then(() => console.log('Connected to MongoDB'))

  .catch((err) => {

    console.error('MongoDB connection error:', err);

    process.exit(1); // Exit on connection failure

  });




// Routes

// Authentication routes (login, signup, logout)

app.use('/api/auth', authRoutes);




// User routes (if any, e.g., profile management)

app.get('/api/user/profile', authenticate, async (req, res) => {

  try {

    const user = await User.findById(req.user.id).select('-password');

    if (!user) {

      return res.status(404).json({ message: 'User not found' });

    }

    res.json({ message: 'User profile', user });

  } catch (err) {

    res.status(500).json({ message: 'Server error' });

  }

});




// Admin routes (protected by authenticate and authorize)

app.use('/api/category', authenticate, authorize(['admin']), categoryRoutes);

app.use('/api/product', authenticate, productRoutes);




// Authenticated user info

app.get('/api/auth/me', authenticate, async (req, res) => {

  try {

    const user = await User.findById(req.user.id).select('-password');

    if (!user) {

      return res.status(404).json({ message: 'User not found' });

    }

    res.json({

      message: 'User logged in',

      user: {

        id: user._id,

        name: user.name,

        role: user.role,

        email: user.email, // Include additional fields as needed

      },

    });

  } catch (err) {

    res.status(500).json({ message: 'Server error' });

  }

});




// Global error handling middleware

app.use((err, req, res, next) => {

  console.error('Error:', err.stack);

  res.status(500).json({ message: 'Something went wrong!' });

});




// Start server

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

I want to store the images in cloudnary. I have created config file for cloudinary in root folder/utils/cloudinary.js
cloudinary.js:-
const cloudinary = require("cloudinary").v2;

require("dotenv").config();




// Configure Cloudinary

cloudinary.config({

  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,

  api_key: process.env.CLOUDINARY_API_KEY,

  api_secret: process.env.CLOUDINARY_API_SECRET,

});





module.exports = { cloudinary };

now for backend name the files in such manner:
controller:- productController.js
Schema:- Product.js

AddProduct.jsx - frontend file

Please implement the following and the design should be very beautiful and eye catching and responsive so that it can work on world's largest secreen to world's smallest screen.

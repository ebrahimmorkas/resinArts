// State updates
const [productData, setProductData] = useState({
  name: "",
  stock: "",
  price: "",
  image: null,
  additionalImages: [], // Added for Basic Information additional images
  selectedCategories: [],
})

const [variants, setVariants] = useState([
  {
    id: Date.now(),
    colorName: "",
    sizes: [
      {
        id: Date.now(),
        length: "",
        breadth: "",
        height: "",
        unit: "cm",
        images: [{ id: Date.now(), file: null, isDefault: true }], // Default image for size
        additionalImages: [], // Optional additional images for size
        reuseImagesFrom: null, // For reusing images from another size
        optionalDetails: [{ id: Date.now(), key: "", value: "" }], // Size-specific details
        reuseDetailsFrom: null, // For reusing details from another size
      },
    ],
    price: "",
    isPriceCommon: "yes",
    stock: "",
    isStockCommon: "yes",
    isDefault: true,
    variantPrices: {},
    variantStocks: {},
    bulkPricing: {},
  },
])

const [additionalImagePreviews, setAdditionalImagePreviews] = useState({}) // For Basic Information additional images

// Track unique image sets for dropdown
const getUniqueImageSizes = (variant) => {
  const uniqueSizes = []
  const seenImageSets = new Set()
  variant.sizes.forEach((size, index) => {
    if (!size.reuseImagesFrom) {
      const dimensions = [size.length, size.breadth, size.height]
        .filter((dim) => dim.trim() !== "")
        .join(" X ")
      const label = `Size ${index + 1} (${variant.colorName}, ${dimensions} ${size.unit})`
      uniqueSizes.push({ sizeId: size.id, label })
      seenImageSets.add(size.id)
    } else if (!seenImageSets.has(size.reuseImagesFrom)) {
      const reusedSize = variant.sizes.find((s) => s.id === size.reuseImagesFrom)
      if (reusedSize) {
        const dimensions = [reusedSize.length, reusedSize.breadth, reusedSize.height]
          .filter((dim) => dim.trim() !== "")
          .join(" X ")
        const label = `Size ${variant.sizes.findIndex((s) => s.id === size.reuseImagesFrom) + 1} (${
          variant.colorName
        }, ${dimensions} ${reusedSize.unit})`
        uniqueSizes.push({ sizeId: reusedSize.id, label })
        seenImageSets.add(reusedSize.id)
      }
    }
  })
  return uniqueSizes
}

// Handle Basic Information additional image
const addProductAdditionalImage = () => {
  setProductData((prev) => ({
    ...prev,
    additionalImages: [...prev.additionalImages, { id: Date.now(), file: null }],
  }))
}

const handleProductAdditionalImageUpload = (imageId, e) => {
  const file = e.target.files[0]
  if (file) {
    setProductData((prev) => ({
      ...prev,
      additionalImages: prev.additionalImages.map((img) =>
        img.id === imageId ? { ...img, file } : img
      ),
    }))
    const reader = new FileReader()
    reader.onload = (e) => {
      setAdditionalImagePreviews((prev) => ({
        ...prev,
        [imageId]: e.target.result,
      }))
    }
    reader.readAsDataURL(file)
  }
}

const removeProductAdditionalImage = (imageId) => {
  setProductData((prev) => ({
    ...prev,
    additionalImages: prev.additionalImages.filter((img) => img.id !== imageId),
  }))
  setAdditionalImagePreviews((prev) => {
    const { [imageId]: removed, ...rest } = prev
    return rest
  })
}

// Handle size-specific image upload (default image)
const handleSizeImageUpload = (variantId, sizeId, e) => {
  const file = e.target.files[0]
  if (file) {
    setVariants((prev) =>
      prev.map((variant) => {
        if (variant.id === variantId) {
          return {
            ...variant,
            sizes: variant.sizes.map((size) => {
              if (size.id === sizeId) {
                return {
                  ...size,
                  images: [{ id: Date.now(), file, isDefault: true }],
                }
              }
              return size
            }),
          }
        }
        return variant
      })
    )
    const reader = new FileReader()
    reader.onload = (e) => {
      setVariantImagePreviews((prev) => ({
        ...prev,
        [sizeId]: e.target.result,
      }))
    }
    reader.readAsDataURL(file)
    setErrors((prev) => ({ ...prev, [`variant_${variantId}_size_${sizeId}_image`]: "" }))
  }
}

// Handle size-specific additional image
const addSizeAdditionalImage = (variantId, sizeId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                additionalImages: [...(size.additionalImages || []), { id: Date.now(), file: null }],
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

const handleSizeAdditionalImageUpload = (variantId, sizeId, imageId, e) => {
  const file = e.target.files[0]
  if (file) {
    setVariants((prev) =>
      prev.map((variant) => {
        if (variant.id === variantId) {
          return {
            ...variant,
            sizes: variant.sizes.map((size) => {
              if (size.id === sizeId) {
                return {
                  ...size,
                  additionalImages: size.additionalImages.map((img) =>
                    img.id === imageId ? { ...img, file } : img
                  ),
                }
              }
              return size
            }),
          }
        }
        return variant
      })
    )
    const reader = new FileReader()
    reader.onload = (e) => {
      setVariantAdditionalImagePreviews((prev) => ({
        ...prev,
        [sizeId]: {
          ...prev[sizeId],
          [imageId]: e.target.result,
        },
      }))
    }
    reader.readAsDataURL(file)
  }
}

const removeSizeAdditionalImage = (variantId, sizeId, imageId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                additionalImages: size.additionalImages.filter((img) => img.id !== imageId),
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
  setVariantAdditionalImagePreviews((prev) => {
    const sizePreviews = { ...prev[sizeId] }
    delete sizePreviews[imageId]
    return { ...prev, [sizeId]: sizePreviews }
  })
}

// Handle reuse images dropdown
const handleReuseImagesChange = (variantId, sizeId, value) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                reuseImagesFrom: value === "no" ? null : value,
                images: value === "no" ? [{ id: Date.now(), file: null, isDefault: true }] : [],
                additionalImages: value === "no" ? [] : [],
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

// Handle size-specific optional details
const addSizeOptionalDetail = (variantId, sizeId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                optionalDetails: [...(size.optionalDetails || []), { id: Date.now(), key: "", value: "" }],
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

const removeSizeOptionalDetail = (variantId, sizeId, detailId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                optionalDetails: size.optionalDetails.filter((detail) => detail.id !== detailId),
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

const updateSizeOptionalDetail = (variantId, sizeId, detailId, field, value) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                optionalDetails: size.optionalDetails.map((detail) =>
                  detail.id === detailId ? { ...detail, [field]: value } : detail
                ),
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

// Handle reuse details dropdown
const handleReuseDetailsChange = (variantId, sizeId, value) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.map((size) => {
            if (size.id === sizeId) {
              return {
                ...size,
                reuseDetailsFrom: value === "no" ? null : value,
                optionalDetails: value === "no" ? [{ id: Date.now(), key: "", value: "" }] : [],
              }
            }
            return size
          }),
        }
      }
      return variant
    })
  )
}

// Update addSizeToVariant to include default fields
const addSizeToVariant = (variantId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        const newSize = {
          id: Date.now(),
          length: "",
          breadth: "",
          height: "",
          unit: "cm",
          images: [{ id: Date.now(), file: null, isDefault: true }],
          additionalImages: [],
          reuseImagesFrom: null,
          optionalDetails: [{ id: Date.now(), key: "", value: "" }],
          reuseDetailsFrom: null,
        }
        return {
          ...variant,
          sizes: [...variant.sizes, newSize],
        }
      }
      return variant
    })
  )
}

// Update removeSizeFromVariant to clean up previews
const removeSizeFromVariant = (variantId, sizeId) => {
  setVariants((prev) =>
    prev.map((variant) => {
      if (variant.id === variantId) {
        return {
          ...variant,
          sizes: variant.sizes.filter((size) => size.id !== sizeId),
          variantPrices: Object.fromEntries(
            Object.entries(variant.variantPrices).filter(([key]) => !key.includes(sizeId))
          ),
          variantStocks: Object.fromEntries(
            Object.entries(variant.variantStocks).filter(([key]) => !key.includes(sizeId))
          ),
          bulkPricing: Object.fromEntries(
            Object.entries(variant.bulkPricing).filter(([key]) => !key.includes(sizeId))
          ),
        }
      }
      return variant
    })
  )
  setVariantImagePreviews((prev) => {
    const { [sizeId]: removed, ...rest } = prev
    return rest
  })
  setVariantAdditionalImagePreviews((prev) => {
    const { [sizeId]: removed, ...rest } = prev
    return rest
  })
}

// Update generateVariantCombinations to use size.id
const generateVariantCombinations = (variant) => {
  if (!variant.colorName) return []
  return variant.sizes
    .filter((size) => {
      const filledDimensions = [size.length, size.breadth, size.height].filter(
        (dim) => dim.trim() !== ""
      ).length
      return filledDimensions >= 2
    })
    .map((size) => {
      const dimensions = [size.length, size.breadth, size.height]
        .filter((dim) => dim.trim() !== "")
        .join(" X ")
      return {
        key: `${variant.colorName}-${size.id}`,
        display: `${variant.colorName}, ${dimensions} ${size.unit}`,
        sizeId: size.id,
      }
    })
}

// Update addVariant to remove variant.image and optionalDetails
const addVariant = () => {
  const newVariant = {
    id: Date.now(),
    colorName: "",
    sizes: [
      {
        id: Date.now(),
        length: "",
        breadth: "",
        height: "",
        unit: "cm",
        images: [{ id: Date.now(), file: null, isDefault: true }],
        additionalImages: [],
        reuseImagesFrom: null,
        optionalDetails: [{ id: Date.now(), key: "", value: "" }],
        reuseDetailsFrom: null,
      },
    ],
    price: "",
    isPriceCommon: "yes",
    stock: "",
    isStockCommon: "yes",
    isDefault: false,
    variantPrices: {},
    variantStocks: {},
    bulkPricing: {},
  }
  setVariants((prev) => [...prev, newVariant])
}

// Update removeVariant to clean up previews
const removeVariant = (variantId) => {
  setVariants((prev) => {
    const updatedVariants = prev.filter((variant) => variant.id !== variantId)
    if (updatedVariants.length > 0 && prev.find((v) => v.id === variantId).isDefault) {
      updatedVariants[0].isDefault = true
    }
    return updatedVariants
  })
  setVariantImagePreviews((prev) => {
    const updated = { ...prev }
    Object.keys(updated).forEach((key) => {
      if (key.startsWith(`${variantId}-`)) {
        delete updated[key]
      }
    })
    return updated
  })
  setVariantAdditionalImagePreviews((prev) => {
    const updated = { ...prev }
    Object.keys(updated).forEach((key) => {
      if (key.startsWith(`${variantId}-`)) {
        delete updated[key]
      }
    })
    return updated
  })
}

// Update validation
const handleSubmit = async (e) => {
  e.preventDefault()
  const newErrors = {}

  if (!productData.name) newErrors.name = "Product name is required"
  if (!productData.selectedCategories.length) newErrors.category_0 = "Main category is required"

  if (!isAnyMainFieldFilled()) {
    variants.forEach((variant, index) => {
      if (!variant.colorName) {
        newErrors[`variant_${index}_color`] = "Color name is required"
      }
      variant.sizes.forEach((size, sizeIndex) => {
        const filledDimensions = [size.length, size.breadth, size.height].filter(
          (dim) => dim.trim() !== ""
        ).length
        if (filledDimensions < 2) {
          newErrors[`variant_${index}_size_${sizeIndex}`] = "At least 2 dimensions are required"
        }
        if (!size.reuseImagesFrom && !size.images[0]?.file) {
          newErrors[`variant_${index}_size_${size.id}_image`] = "Default image is required"
        }
      })
    })
  } else {
    if (!productData.stock) newErrors.stock = "Stock is required"
    if (!productData.price) newErrors.price = "Price is required"
    if (!productData.image) newErrors.image = "Image is required"
  }

  if (Object.keys(newErrors).length > 0) {
    setErrors(newErrors)
    return
  }

  const formDataToSend = new FormData()
  formDataToSend.append("name", productData.name)
  formDataToSend.append("stock", productData.stock)
  formDataToSend.append("price", productData.price)
  if (productData.image) formDataToSend.append("image", productData.image)
  formDataToSend.append("details", JSON.stringify(productDetails.filter((detail) => detail.key && detail.value)))
  formDataToSend.append("categoryId", productData.selectedCategories[productData.selectedCategories.length - 1] || "")
  formDataToSend.append("categoryPath", JSON.stringify(productData.selectedCategories))
  formDataToSend.append("mainBulkPricing", JSON.stringify(isAnyMainFieldFilled() ? mainBulkPricing : []))
  productData.additionalImages.forEach((img, index) => {
    if (img.file) {
      formDataToSend.append(`additional_image_${img.id}`, img.file)
    }
  })

  const variantsToSend = variants.map((variant) => ({
    ...variant,
    sizes: variant.sizes.map((size) => ({
      ...size,
      images: size.reuseImagesFrom ? [] : size.images.map((img) => img.id),
      additionalImages: size.reuseImagesFrom ? [] : size.additionalImages.map((img) => img.id),
      optionalDetails: size.reuseDetailsFrom ? [] : size.optionalDetails.filter((d) => d.key && d.value),
    })),
  }))
  formDataToSend.append("variants", JSON.stringify(isAnyMainFieldFilled() ? [] : variantsToSend))

  variants.forEach((variant, index) => {
    variant.sizes.forEach((size) => {
      if (!size.reuseImagesFrom) {
        if (size.images[0]?.file) {
          formDataToSend.append(`variant_${index}_size_${size.id}_image`, size.images[0].file)
        }
        size.additionalImages.forEach((img) => {
          if (img.file) {
            formDataToSend.append(`variant_${index}_size_${size.id}_additional_${img.id}`, img.file)
          }
        })
      }
    })
  })

  try {
    const response = await axios.post("https://api.mouldmarket.in/api/product/add", formDataToSend, {
      headers: { "Content-Type": "multipart/form-data" },
      withCredentials: true,
    })
    console.log("Product added successfully:", response.data)
    alert("Product added successfully!")
    setProductData({ name: "", stock: "", price: "", image: null, additionalImages: [], selectedCategories: [] })
    setSelectedPath([])
    setSubCategoryOptions([])
    setImagePreview(null)
    setAdditionalImagePreviews({})
    setProductDetails([
      { id: Date.now(), key: "", value: "" },
      { id: Date.now() + 1, key: "", value: "" },
    ])
    setMainBulkPricing([])
    setVariants([
      {
        id: Date.now(),
        colorName: "",
        sizes: [
          {
            id: Date.now(),
            length: "",
            breadth: "",
            height: "",
            unit: "cm",
            images: [{ id: Date.now(), file: null, isDefault: true }],
            additionalImages: [],
            reuseImagesFrom: null,
            optionalDetails: [{ id: Date.now(), key: "", value: "" }],
            reuseDetailsFrom: null,
          },
        ],
        price: "",
        isPriceCommon: "yes",
        stock: "",
        isStockCommon: "yes",
        isDefault: true,
        variantPrices: {},
        variantStocks: {},
        bulkPricing: {},
      },
    ])
    setVariantImagePreviews({})
    setVariantAdditionalImagePreviews({})
  } catch (error) {
    console.error("Error adding product:", error)
    alert("Failed to add product: " + (error.response?.data?.message || "Please try again."))
  }
}